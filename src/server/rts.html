<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="theme-color" content="#081427" />
<meta name="mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="Antfarm RTS" />
<link rel="manifest" href="/manifest.webmanifest" />
<title>Antfarm RTS Command Grid</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Orbitron:wght@500;700&family=Geist+Mono&display=swap" rel="stylesheet">
<style>
:root {
  --bg-a:#050913;
  --bg-b:#081325;
  --bg-c:#0a1a31;
  --corpus-ice:#e6fbff;
  --corpus-teal:#6ff8ff;
  --corpus-blue:#68c7ff;
  --corpus-line:#7fcbff5a;
  --panel:#0b1a2dcc;
  --panel-edge:#73c7ff55;
  --muted:#8aa3be;
  --ok:#4df5bf;
  --warn:#ffd06b;
  --bad:#ff7198;
  --dock-w:min(290px, 24vw);
  --command-h:138px;
  --screen-pad:12px;
  --panel-gutter:var(--dock-w);
}
* {
  box-sizing:border-box;
  margin:0;
  padding:0;
  -ms-overflow-style:none;
  scrollbar-width:none;
}
*::-webkit-scrollbar {
  width:0;
  height:0;
  display:none;
  background:transparent;
}
html, body {
  width:100%;
  height:100%;
  overflow:hidden;
}
body {
  font-family:Inter,system-ui,sans-serif;
  color:var(--corpus-ice);
  min-height:100vh;
  overflow:hidden;
  background:
    radial-gradient(circle at 12% 12%, #1e3258 0%, #0b1528 24%, transparent 52%),
    radial-gradient(circle at 88% 18%, #163755 0%, #0a1426 25%, transparent 58%),
    linear-gradient(165deg,var(--bg-c) 0%,var(--bg-b) 45%,var(--bg-a) 100%);
}
.notice { font-size:11px; color:var(--muted); }
.install-app-cta {
  position:fixed;
  right:calc(var(--dock-w) + 14px);
  bottom:calc(var(--command-h) + 14px);
  z-index:260;
  border:1px solid #86d7ff;
  border-radius:999px;
  background:linear-gradient(160deg,#0d3155 0%,#0a233d 100%);
  color:#dff6ff;
  font-weight:600;
  letter-spacing:.2px;
  box-shadow:0 10px 28px #02101f99;
}
.install-app-cta[hidden] { display:none !important; }
button,select,input,textarea {
  border:1px solid #4f799f;
  background:#0b1b30;
  color:var(--corpus-ice);
  border-radius:8px;
  padding:7px 10px;
}
button { cursor:pointer; }
button:hover { border-color:#8de7ff; box-shadow:0 0 0 1px #95e6ff44 inset; }
.layout { position:relative; width:100vw; height:100vh; }
.world-wrap {
  position:relative;
  inset:0;
  width:100%;
  height:100%;
  overflow:hidden;
  background:#050913;
}
.world-bg {
  position:absolute; inset:0;
  z-index:0;
  background-image:url('/rts-sprites/bg-space-tile-20260212b.png?v=20260212b');
  background-repeat:repeat;
  background-size:128px 128px;
  background-position:calc(var(--cam-x, 0px) * -0.75) calc(var(--cam-y, 0px) * -0.75);
  image-rendering:pixelated;
  image-rendering:crisp-edges;
}
.world {
  position:absolute;
  inset:0;
  z-index:2;
  transform:translate3d(calc(var(--cam-x, 0px) * -1), calc(var(--cam-y, 0px) * -1), 0);
  will-change:transform;
}
.path-layer {
  pointer-events:auto;
  z-index:1;
}
.rts-path {
  position:absolute;
  height:8px;
  transform-origin:left center;
  border-radius:999px;
  border:1px solid #4fa0cb66;
  background:
    repeating-linear-gradient(
      90deg,
      #0c2135 0px,
      #0c2135 12px,
      #1f4d6d 12px,
      #1f4d6d 18px
    );
  box-shadow:0 0 8px #6ad8ff33;
  cursor:pointer;
  pointer-events:auto;
}
.rts-path.active {
  background:
    repeating-linear-gradient(
      90deg,
      #15392e 0px,
      #15392e 12px,
      #2a7f67 12px,
      #2a7f67 18px
    );
  box-shadow:0 0 14px #76ffe099;
}
.rts-path::after {
  content:'';
  position:absolute;
  right:-7px;
  top:50%;
  transform:translateY(-50%);
  width:0;
  height:0;
  border-top:6px solid transparent;
  border-bottom:6px solid transparent;
  border-left:8px solid #8ed8ff;
}
.rts-path.active::after { border-left-color:#a4ffe0; }
.rts-path.is-selected {
  box-shadow:0 0 0 2px #b2f0ff, 0 0 16px #9ae7ff;
}
.build-note {
  position:absolute;
  min-width:130px;
  max-width:220px;
  border:1px solid #79dcffb2;
  border-radius:8px;
  background:#0a1f34ee;
  padding:6px 8px;
  color:#dff8ff;
  font-size:10px;
  line-height:1.25;
  box-shadow:0 6px 14px #00000077;
  pointer-events:auto;
}
.build-note a {
  color:#95f1ff;
  text-decoration:none;
  border-bottom:1px solid #95f1ff66;
}
.build-note.bad {
  border-color:#ff7f9dbb;
  background:#2a0b14f0;
  color:#ffd5df;
  box-shadow:0 8px 18px #2d0713cc;
}
.build-note.bad .bad-tag {
  display:inline-block;
  margin-bottom:4px;
  padding:1px 6px;
  border:1px solid #ff7f9dcc;
  border-radius:999px;
  color:#ff9db5;
  font-weight:700;
  letter-spacing:.4px;
}
.panel {
  background:var(--panel);
  border:1px solid var(--panel-edge);
  border-radius:0;
  padding:12px;
}
.panel h3 {
  font-family:Orbitron,sans-serif;
  font-size:12px;
  letter-spacing:.5px;
  margin-bottom:9px;
  color:var(--corpus-teal);
}
.hud {
  position:absolute;
  top:0;
  bottom:0;
  left:auto;
  right:0;
  width:var(--dock-w);
  display:block;
  gap:0;
  pointer-events:none;
  z-index:220;
}
.hud-right { display:flex; gap:0; pointer-events:auto; flex-direction:column; width:100%; height:100%; max-height:100%; overflow:hidden; }
#livePanel,
#selectionPanel { display:none !important; }
#actionPanel {
  background:linear-gradient(180deg,#0a1b31f2 0%, #081427f2 100%);
  min-height:100%;
  height:100%;
  border-radius:0;
  border-right:0;
  border-top:0;
  border-bottom:0;
  overflow-y:auto;
  overscroll-behavior:contain;
}
.layout.feature-mode #actionPanel { min-height:100%; }
.command-bar {
  position:fixed;
  left:calc(var(--panel-gutter) - 1px) !important;
  right:calc(var(--panel-gutter) - 1px);
  bottom:0;
  transform:none !important;
  border:1px solid var(--panel-edge);
  border-radius:0;
  background:linear-gradient(180deg,#09172d,#081224);
  display:flex;
  align-items:stretch;
  width:auto;
  height:var(--command-h);
  overflow:visible;
  z-index:240;
  pointer-events:auto;
}
.command-left {
  display:none;
}
.command-title { font-family:Orbitron,sans-serif; font-size:11px; color:#8cdcff; letter-spacing:.6px; }
.command-icon-btn {
  appearance:none;
  width:38px;
  height:38px;
  padding:0;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  border:1px solid #5584ab;
  border-radius:10px;
  background:linear-gradient(160deg,#0f2842 0%,#0a1e34 60%,#081629 100%);
}
.command-icon-btn img {
  width:24px;
  height:24px;
  object-fit:contain;
  image-rendering:pixelated;
  image-rendering:crisp-edges;
}
.command-grid {
  padding:8px;
  width:100%;
  height:100%;
  display:flex;
  gap:8px;
  align-items:center;
  overflow-x:auto;
  overflow-y:visible;
}
.palette-card {
  --palette-bg:none;
  --overlay-opacity:0.85;
  appearance:none;
  border:1px solid #5584ab;
  width:116px;
  height:116px;
  min-width:116px;
  border-radius:12px;
  background-image:
    linear-gradient(
      150deg,
      rgb(15 40 66 / var(--overlay-opacity)) 0%,
      rgb(10 30 52 / var(--overlay-opacity)) 58%,
      rgb(8 22 41 / var(--overlay-opacity)) 100%
    ),
    var(--palette-bg);
  background-size:auto, cover;
  background-position:center, center;
  background-repeat:no-repeat, no-repeat;
  box-shadow:0 7px 14px #00000066;
  cursor:grab;
  display:flex;
  align-items:center;
  justify-content:center;
  position:relative;
}
.palette-card:hover {
  --overlay-opacity:0;
  border-color:#8de7ff;
  box-shadow:0 0 0 1px #95e6ff44 inset, 0 8px 18px #0000007a;
}
.palette-card.active {
  --overlay-opacity:0;
  border-color:#8de7ff;
  box-shadow:0 0 0 1px #95e6ff77 inset, 0 0 20px #57dfff4f;
}
.palette-card:active { cursor:grabbing; }
.palette-sprite {
  width:84px;
  height:84px;
  object-fit:contain;
  opacity:.95;
  filter:none;
  image-rendering:pixelated;
  image-rendering:crisp-edges;
}
.palette-card .hotkey {
  font-size:10px;
  color:#8cdcff;
  position:absolute;
  right:6px;
  bottom:4px;
  font-family:'Geist Mono', monospace;
  letter-spacing:.5px;
}
.palette-tooltip {
  position:absolute;
  left:50%;
  bottom:calc(100% + 10px);
  transform:translateX(-50%) translateY(8px);
  width:220px;
  padding:9px 10px;
  border:1px solid #79dfff;
  border-radius:10px;
  background:linear-gradient(180deg, #0b233c 0%, #09182c 100%);
  box-shadow:0 12px 20px #0000008a;
  color:#d9f7ff;
  text-align:left;
  opacity:0;
  pointer-events:none;
  transition:opacity .14s ease, transform .14s ease;
  z-index:260;
}
.palette-tooltip::after {
  content:'';
  position:absolute;
  left:50%;
  top:100%;
  width:10px;
  height:10px;
  transform:translateX(-50%) rotate(45deg);
  border-right:1px solid #79dfff;
  border-bottom:1px solid #79dfff;
  background:#09182c;
}
.palette-tooltip .tooltip-title {
  display:block;
  font-family:Orbitron,sans-serif;
  font-size:11px;
  letter-spacing:.4px;
  color:#90e5ff;
  margin-bottom:3px;
}
.palette-tooltip .tooltip-copy {
  display:block;
  font-size:11px;
  line-height:1.35;
  color:#caeefb;
}
.palette-card:hover .palette-tooltip,
.palette-card:focus-visible .palette-tooltip {
  opacity:1;
  transform:translateX(-50%) translateY(0);
}
.world-wrap.drop-armed { outline:2px dashed #8de7ff; outline-offset:-6px; }
.placement-layer { pointer-events:none; }
.placement-layer { z-index:3; }
.placement-ghost { opacity:.45; border-style:dashed; }
.placement-ghost.invalid .building-sprite { filter:hue-rotate(-42deg) saturate(1.25) brightness(1.05); }
.building-sprite {
  width:var(--sprite-w,100%);
  height:var(--sprite-h,100%);
  object-fit:contain;
  display:block;
  pointer-events:none;
  filter:none;
  image-rendering:auto;
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
}
.build-card {
  border:1px solid #3f6283;
  border-radius:10px;
  padding:8px;
  background:linear-gradient(150deg,#0e223a 0%,#091a2f 58%,#081629 100%);
  box-shadow:0 9px 16px #00000066;
}
.build-card strong { display:block; font-size:12px; margin-bottom:5px; color:#caf4ff; }
.build-card small { color:var(--muted); font-size:11px; display:block; }
.kv { font-size:12px; color:var(--muted); margin-bottom:7px; }
.kv strong { color:var(--corpus-ice); }
.entity {
  position:absolute;
  transform-style:preserve-3d;
  filter:none;
  pointer-events:auto;
}
.iso-core {
  position:relative;
  border:none;
  background:none;
  overflow:visible;
}
.iso-core:before {
  content:none;
  position:absolute;
  inset:-1px;
  background:linear-gradient(130deg,#d9fbff2f 0%,transparent 28%,transparent 65%,#58deff2f 100%);
  pointer-events:none;
}
.iso-top,
.iso-side {
  display:none;
}
.iso-top {
  left:0;
  right:0;
}
.iso-side {
  top:0;
  right:0;
}
.base { width:var(--footprint-w,220px); height:var(--footprint-h,154px); }
.base .iso-core { width:100%; height:100%; border-radius:0; padding:0; }
.movable { cursor:move; }
.base .name { font-size:12px; font-weight:700; color:#baf5ff; }
.base .repo { margin-top:6px; font-size:11px; color:#9eb5cb; font-family:'Geist Mono', monospace; }
.base .conduit {
  margin-top:12px;
  height:8px;
  border-radius:999px;
  border:1px solid #7de7ff7a;
  background:linear-gradient(90deg,#40d8ff,#8fffff,#4ec9ff);
  box-shadow:0 0 10px #62deff77;
}
.building { width:var(--footprint-w,132px); min-height:var(--footprint-h,88px); }
.building .iso-core { border-radius:0; padding:0; min-height:var(--footprint-h,88px); cursor:pointer; }
.building .title { font-size:12px; font-weight:600; margin-bottom:7px; }
.meta { display:flex; justify-content:space-between; align-items:center; font-size:11px; color:var(--muted); margin-bottom:7px; }
.badge { font-size:10px; border:1px solid #5d8cae; border-radius:999px; padding:2px 6px; }
.port-chip {
  position:absolute;
  left:8px;
  top:8px;
  z-index:5;
  border:1px solid #4d7da0;
  border-radius:999px;
  padding:2px 7px;
  font-size:10px;
  line-height:1.1;
  color:#c9edff;
  background:#07172bcc;
  font-family:'Geist Mono', monospace;
}
.progress { height:8px; border-radius:999px; border:1px solid #4f7693; overflow:hidden; background:#08101d; }
.bar { height:100%; background:linear-gradient(90deg,#58ffe4,#66cbff); }
.pr-link { display:block; margin-top:8px; font-size:11px; color:#a7efff; text-decoration:none; border:1px solid #4f8cae; border-radius:7px; padding:6px; }
.ghost { opacity:.86; border-style:dashed; }
.draft-ghost { opacity:.46; border-style:dashed; }
.draft-ghost .iso-core { border-color:#86dcffa2; }
.is-half-transparent { opacity:.5; }
.is-failed { filter:saturate(0.7) hue-rotate(-18deg) brightness(0.92); }
.entity.is-selected .iso-core {
  outline:2px solid #8de7ff;
  outline-offset:3px;
  box-shadow:0 0 0 1px #d4f7ff55 inset, 0 0 18px #5fe7ff7a;
}
.unit {
  position:absolute;
  width:32px; height:32px;
  background:url('/rts-sprites/unit-cephalon-test.png?v=20260212b') center/contain no-repeat;
  filter:none;
  cursor:pointer;
  animation:float-unit 1.8s ease-in-out infinite alternate;
  image-rendering:pixelated;
  image-rendering:crisp-edges;
}
.unit.is-selected,
.subunit.is-selected {
  filter:drop-shadow(0 0 7px #7de7ff);
}
.unit-model-chip {
  position:absolute;
  transform:translate(13px,-9px);
  background:#0d2035d9;
  border:1px solid #5486a8;
  border-radius:999px;
  padding:1px 6px;
  white-space:nowrap;
  font-size:9px;
  color:#a3efff;
  pointer-events:none;
}
.subunit {
  position:absolute;
  width:16px; height:16px;
  background:url('/rts-sprites/subunit-cephalon-test.png?v=20260212b') center/contain no-repeat;
  filter:none;
  image-rendering:pixelated;
  image-rendering:crisp-edges;
}
.camera-hint {
  position:absolute;
  left:12px;
  bottom:152px;
  pointer-events:none;
  z-index:45;
  background:#0b1a2fbd;
  border:1px solid #436f91;
  border-radius:8px;
  padding:6px 8px;
}
.panel-toolbar {
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
  margin-bottom:10px;
}
.panel-toolbar .notice { white-space:nowrap; }
.panel-delete {
  border-color:#7d4760;
  background:#2a1320;
  color:#ffd4e2;
}
.panel-delete:hover { border-color:#cf7fa2; }
.library-modal {
  position:fixed;
  inset:2vh 2vw;
  z-index:1200;
  border:1px solid #4c7698;
  border-radius:12px;
  background:linear-gradient(160deg,#0b1a2e 0%,#071423 100%);
  box-shadow:0 24px 80px #000000cc;
  display:flex;
  flex-direction:column;
}
.library-modal[hidden] { display:none; }
.library-modal-header {
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding:10px 12px;
  border-bottom:1px solid #33556f;
}
.library-modal-body {
  flex:1;
  min-height:0;
  display:grid;
  grid-template-columns:minmax(340px, 36%) 1fr;
  gap:10px;
  padding:10px;
}
.library-file-list {
  border:1px solid #375a75;
  border-radius:10px;
  padding:8px;
  background:#091728;
  overflow:auto;
}
.library-file-row {
  width:100%;
  text-align:left;
  border:1px solid #395b77;
  border-radius:8px;
  margin-bottom:7px;
  padding:7px 8px;
  background:#0f243a;
}
.library-file-row.active { border-color:#8de7ff; box-shadow:0 0 0 1px #8de7ff44 inset; }
.library-file-name { display:block; font-weight:600; color:#d3efff; margin-bottom:2px; }
.library-file-meta { display:block; font-size:11px; color:#99b8ce; }
.library-split {
  margin:8px 0;
  border-top:1px solid #4e708d;
  padding-top:8px;
}
.library-preview {
  border:1px solid #375a75;
  border-radius:10px;
  background:#06111d;
  display:flex;
  flex-direction:column;
  min-height:0;
}
.library-preview-head { padding:8px 10px; border-bottom:1px solid #2f4d66; font-size:12px; color:#a8d3ea; }
.library-preview textarea {
  flex:1;
  min-height:0;
  margin:0;
  border:0;
  border-radius:0 0 10px 10px;
  resize:none;
  padding:12px;
  font-family:'Geist Mono', monospace;
  font-size:12px;
  line-height:1.45;
  color:#d8ecfb;
  background:#040b14;
}
@media (max-width: 900px) {
  .library-modal { inset:1vh 1vw; }
  .library-modal-body { grid-template-columns:1fr; }
}
.building-hover {
  position:fixed;
  min-width:180px;
  max-width:260px;
  padding:8px 10px;
  border:1px solid #7de3ff;
  border-radius:10px;
  background:linear-gradient(180deg,#0b223a 0%,#071629 100%);
  box-shadow:0 10px 22px #00000080;
  pointer-events:none;
  z-index:140;
  display:none;
}
.building-hover strong {
  display:block;
  font-size:11px;
  color:#bff3ff;
  margin-bottom:3px;
}
.building-hover span {
  display:block;
  font-size:11px;
  color:#ccecf8;
  line-height:1.3;
}
@keyframes float-unit { from { transform:translateY(-2px); } to { transform:translateY(2px); } }
.skill-grid { display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:6px; }
.skill { border:1px solid #416e90; border-radius:8px; padding:6px; font-size:11px; background:#0a1b2f; }
input[type="text"], input:not([type]), textarea { width:100%; margin-top:4px; }
textarea { min-height:132px; resize:vertical; font-family:Inter,system-ui,sans-serif; }
.status-dot { display:inline-block; width:8px; height:8px; border-radius:50%; margin-right:6px; }
.agent-list { display:flex; flex-direction:column; gap:6px; margin-top:8px; }
.agent-row {
  border:1px solid #3f6788;
  border-radius:8px;
  padding:7px 8px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
  font-size:11px;
  background:#0b1a2f;
  cursor:pointer;
}
.agent-row:hover { border-color:#85dfff; }
.agent-row.active { border-color:#8de7ff; box-shadow:0 0 0 1px #95e6ff44 inset; }
.agent-meta { display:flex; align-items:center; gap:6px; min-width:0; }
.agent-name { font-family:'Geist Mono', monospace; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:180px; }
.agent-actions { display:flex; align-items:center; gap:6px; }
.agent-restart {
  border:1px solid #7f95b0;
  background:#122237;
  color:#cbe9ff;
  border-radius:6px;
  padding:2px 6px;
  font-size:10px;
}
.agent-restart:hover { border-color:#a1c6ea; }
.agent-redo {
  border:1px solid #5f9b78;
  background:#102a1f;
  color:#cfffe4;
  border-radius:6px;
  padding:2px 6px;
  font-size:10px;
}
.agent-redo:hover { border-color:#81d6a9; }
.term-wrap {
  margin-top:8px;
  border:1px solid #456c8d;
  border-radius:8px;
  background:#040b14;
  overflow:hidden;
}
.term-head {
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:6px 8px;
  border-bottom:1px solid #34556f;
  font-size:10px;
  color:var(--muted);
}
.term-actions {
  display:flex;
  align-items:center;
  gap:8px;
}
.term-copy {
  border:1px solid #7f95b0;
  background:#122237;
  color:#cbe9ff;
  border-radius:6px;
  padding:2px 6px;
  font-size:10px;
}
.term-copy:hover { border-color:#a1c6ea; }
.term-view {
  max-height:420px;
  min-height:280px;
  overflow:auto;
  padding:12px;
  font-family:'Geist Mono', monospace;
  font-size:13px;
  line-height:1.55;
  white-space:pre;
  color:#c9f5ff;
  background:#020913;
}
.prompt-text {
  margin:0;
  padding:8px 10px;
  font-family:inherit;
  font-size:13px;
  line-height:1.45;
  white-space:pre-wrap;
  word-break:break-word;
  color:#d7edf8;
  max-height:220px;
  overflow:auto;
}
.cli-panel {
  border:1px solid #3b6384;
  border-radius:8px;
  background:#050d17;
  padding:8px;
}
.cli-head {
  display:flex;
  justify-content:space-between;
  font-family:'Geist Mono', monospace;
  font-size:10px;
  color:#8bdfff;
  margin-bottom:6px;
}
.cli-body {
  max-height:200px;
  overflow:auto;
  font-family:'Geist Mono', monospace;
  font-size:11px;
  line-height:1.35;
  white-space:pre;
  color:#c9f5ff;
}
.unit.live-running { filter:saturate(1.1) brightness(1.05); }
.unit.live-stale { filter:hue-rotate(-30deg) saturate(1.2); }
@media (max-width:1180px) {
  :root { --dock-w:min(280px, 30vw); --command-h:128px; --panel-gutter:var(--dock-w); }
  .hud-right { width:100%; max-height:100%; }
  .camera-hint { bottom:170px; }
}
@media (max-width:760px) {
  :root { --dock-w:min(250px, 68vw); --command-h:118px; --screen-pad:8px; --panel-gutter:var(--screen-pad); }
  .hud {
    top:0;
    bottom:0;
    left:auto;
    right:0;
    width:var(--dock-w);
    height:auto;
  }
  .hud-right {
    width:100%;
    max-height:100%;
  }
  .command-bar {
    left:calc(var(--panel-gutter) - 1px) !important;
    right:calc(var(--panel-gutter) - 1px);
    width:auto;
    transform:none !important;
    bottom:0;
    position:fixed;
  }
  .palette-card {
    width:88px;
    height:88px;
    min-width:88px;
  }
  .palette-sprite {
    width:60px;
    height:60px;
  }
  .palette-tooltip {
    width:180px;
    font-size:10px;
  }
  .term-view {
    min-height:180px;
    max-height:260px;
    font-size:12px;
  }
}
</style>
</head>
<body>
  <div class="layout">
    <div class="world-wrap" id="worldWrap">
      <div class="world-bg"></div>
      <div id="world" class="world"></div>
      <div id="pathLayer" class="world path-layer"></div>
      <div id="placementLayer" class="world placement-layer"></div>
    </div>
    <div class="hud">
      <div class="hud-right">
        <div class="panel" id="livePanel">
          <h3>Live Agent TTY</h3>
          <div class="notice">Loading machine state...</div>
        </div>
        <div class="panel" id="selectionPanel">
          <h3>Selection Panel</h3>
          <div class="notice">Select base/building/unit for RTS-style intel and actions.</div>
        </div>
        <div class="panel" id="actionPanel">
          <h3>Action Console</h3>
          <div class="notice">Use build icons to place Base, Feature Forge, Research Lab, Warehouse, University, Library, or Power Plant.</div>
        </div>
      </div>
    </div>

    <section class="command-bar">
      <div class="command-grid">
        <button class="palette-card" draggable="true" data-building="base" title="Base Core (B)" style="--palette-bg:url('/rts-sprites/base_preview_3-20260213a.png?v=20260213a');">
          <span class="palette-tooltip" role="tooltip">
            <span class="tooltip-title">Base Core</span>
            <span class="tooltip-copy">Main command hub. Place first to anchor routing and runtime links.</span>
          </span>
          <span class="hotkey">B</span>
        </button>
        <button class="palette-card" draggable="true" data-building="feature" title="Feature Forge (F)" style="--palette-bg:url('/rts-sprites/feature-forge-ogame-preview-20260212k.webp?v=20260212k');">
          <span class="palette-tooltip" role="tooltip">
            <span class="tooltip-title">Feature Forge</span>
            <span class="tooltip-copy">Creates feature runs. Link a base repo, draft stories, and launch agents.</span>
          </span>
          <span class="hotkey">F</span>
        </button>
        <button class="palette-card" draggable="true" data-building="research" title="Research Lab (L)" style="--palette-bg:url('/rts-sprites/research-lab-ogame-preview-20260212k.webp?v=20260212k');">
          <span class="palette-tooltip" role="tooltip">
            <span class="tooltip-title">Research Lab</span>
            <span class="tooltip-copy">Scans repos and generates plan cards. Drag plans to seed feature drafts.</span>
          </span>
          <span class="hotkey">L</span>
        </button>
        <button class="palette-card" draggable="true" data-building="warehouse" title="Warehouse (W)" style="--palette-bg:url('/rts-sprites/warehouse-ogame-preview-20260212k.webp?v=20260212k');">
          <span class="palette-tooltip" role="tooltip">
            <span class="tooltip-title">Warehouse</span>
            <span class="tooltip-copy">Stores completed artifacts and links them back to base logistics.</span>
          </span>
          <span class="hotkey">W</span>
        </button>
        <button class="palette-card" draggable="true" data-building="university" title="University (U)" style="--palette-bg:url('/rts-sprites/university_preview-20260212a.webp?v=20260212a');">
          <span class="palette-tooltip" role="tooltip">
            <span class="tooltip-title">University</span>
            <span class="tooltip-copy">Advanced planning campus. Uses Research Lab mechanics with a distinct skin.</span>
          </span>
          <span class="hotkey">U</span>
        </button>
        <button class="palette-card" draggable="true" data-building="library" title="Library (Y)" style="--palette-bg:url('/rts-sprites/library_preview-20260212a.webp?v=20260212a');">
          <span class="palette-tooltip" role="tooltip">
            <span class="tooltip-title">Library</span>
            <span class="tooltip-copy">Knowledge vault. Uses Warehouse mechanics with a distinct skin.</span>
          </span>
          <span class="hotkey">Y</span>
        </button>
        <button class="palette-card" draggable="true" data-building="power" title="Power Plant (P)" style="--palette-bg:url('/rts-sprites/power_preview-20260212a.webp?v=20260212a');">
          <span class="palette-tooltip" role="tooltip">
            <span class="tooltip-title">Power Plant P</span>
            <span class="tooltip-copy">Cron station. Uses Library placement and shows all active cron jobs.</span>
          </span>
          <span class="hotkey">P</span>
        </button>
      </div>
    </section>
  </div>
  <div id="buildingHoverCard" class="building-hover" aria-hidden="true"></div>
  <button id="installAppBtn" class="install-app-cta" type="button" hidden aria-live="polite">Install App</button>

<script>
const state = {
  workflows: [], runs: [],
  localRepos: [],
  placementMode: null,
  bases: [], units: [], buildings: [],
  customBases: [],
  baseDrafts: [],
  featureBuildings: [],
  researchBuildings: [],
  warehouseBuildings: [],
  hiddenBelts: {},
  runLayoutOverrides: {},
  portByPath: {},
  runtime: null,
  live: { ts:'', activeRunCount:0, pendingRunCount:0, runningAgentCount:0, activeAgents:[] },
  liveDeployInFlight: false,
  liveDeployNotice: '',
  diag: null,
  liveStream: null,
  runSig: '',
  selected: null,
  persistTimer: null,
  camera: { x: 0, y: 0 },
  cameraDrag: { active:false, startX:0, startY:0, originX:0, originY:0 },
  draggingEntity: null,
  draggingMoved: false,
  suppressWorldClick: false,
  recentFeaturePlacementUntil: 0,
  stream: {
    runId: null,
    agentId: null,
    stepId: null,
    targetLines: [],
    displayedLines: [],
    pollTimer: null,
    revealTimer: null,
    stepStatus: 'idle',
    loading: false
  },
  streamSelectionByRun: {},
  featureMode: false,
  runStatusOverrides: {},
  libraryBrowser: { role: 'all', tag: 'all', q: '', selectedPath: '' }
};
// Manually bump this when changing Command Console UI so refresh state is obvious.
const COMMAND_CONSOLE_VERSION = 'v2026.02.12.5';
const SERVICE_WORKER_URL = '/service-worker.v1.js';
let deferredInstallPrompt = null;

function renderInstallPromptState(){
  const installBtn = document.getElementById('installAppBtn');
  if (!(installBtn instanceof HTMLButtonElement)) return;
  installBtn.hidden = !deferredInstallPrompt;
}

function initInstallPrompt(){
  const installBtn = document.getElementById('installAppBtn');
  if (installBtn instanceof HTMLButtonElement) {
    installBtn.addEventListener('click', async () => {
      const promptEvent = deferredInstallPrompt;
      if (!promptEvent) return;
      deferredInstallPrompt = null;
      renderInstallPromptState();
      try {
        promptEvent.prompt();
        await promptEvent.userChoice;
      } catch {}
    });
  }
  window.addEventListener('beforeinstallprompt', (event) => {
    event.preventDefault();
    deferredInstallPrompt = event;
    renderInstallPromptState();
  });
  window.addEventListener('appinstalled', () => {
    deferredInstallPrompt = null;
    renderInstallPromptState();
  });
  renderInstallPromptState();
}

function registerServiceWorker(){
  if (!('serviceWorker' in navigator)) return;
  window.addEventListener('load', async () => {
    try {
      const registration = await navigator.serviceWorker.register(SERVICE_WORKER_URL, { scope: '/' });
      const watchInstallingWorker = (installingWorker) => {
        if (!installingWorker) return;
        installingWorker.addEventListener('statechange', () => {
          if (installingWorker.state === 'installed' && navigator.serviceWorker.controller) {
            registration.update().catch(() => {});
          }
        });
      };
      watchInstallingWorker(registration.installing);
      registration.addEventListener('updatefound', () => watchInstallingWorker(registration.installing));
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') registration.update().catch(() => {});
      });
      window.addEventListener('focus', () => registration.update().catch(() => {}));
    } catch (error) {
      console.warn('Service worker registration failed:', error);
    }
  });
}

const RTS_SPRITE_URLS = [
  '/rts-sprites/bg-space-tile-20260212b.png?v=20260212b',
  '/rts-sprites/base_sprite-20260212a.png?v=20260212a',
  '/rts-sprites/feature_factory_sprite.png?v=20260212v',
  '/rts-sprites/research_lab_sprite.png?v=20260212v',
  '/rts-sprites/warehouse_sprite.png?v=20260212v',
  '/rts-sprites/university_sprite-20260212a.png?v=20260212a',
  '/rts-sprites/library_sprite-20260212a.png?v=20260212a',
  '/rts-sprites/power_sprite-20260212a.png?v=20260212a',
  '/rts-sprites/base_preview_3-20260213a.png?v=20260213a',
  '/rts-sprites/feature-forge-ogame-preview-20260212k.webp?v=20260212k',
  '/rts-sprites/research-lab-ogame-preview-20260212k.webp?v=20260212k',
  '/rts-sprites/warehouse-ogame-preview-20260212k.webp?v=20260212k',
  '/rts-sprites/university_preview-20260212a.webp?v=20260212a',
  '/rts-sprites/library_preview-20260212a.webp?v=20260212a',
  '/rts-sprites/power_preview-20260212a.webp?v=20260212a',
  '/rts-sprites/unit-cephalon-test.png?v=20260212b',
  '/rts-sprites/subunit-cephalon-test.png?v=20260212b'
];
let spritesPreloadPromise = null;

const skillTrees = {
  architect: ['System Mapping','Dependency Radar','Design Sync','API Stability'],
  builder: ['Code Synthesis','Refactor Pulse','Patch Weaving','Perf Trim'],
  verifier: ['Spec Scan','Regression Sweep','Edge Probe','Release Gate'],
  orchestrator: ['Task Routing','Priority Queue','Load Balancing','Auto Recovery'],
  subagent: ['Micro-task','Orbit Assist','Retry Loop','Signal Relay']
};

function esc(s){ return (s||'').replace(/[&<>\"]/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[m])); }
function dbg(tag, data){
  try { console.log(`[rts:${tag}]`, data || ''); } catch {}
}
function baseAgentId(agentId){
  return String(agentId || '').replace(/@run:[^/]+$/, '');
}
function streamSelectionKey(agentId, stepId = ''){
  return `${String(agentId || '')}::${String(stepId || '')}`;
}
function parseStreamSelectionKey(key){
  const raw = String(key || '');
  const splitAt = raw.indexOf('::');
  if (splitAt < 0) return { agentId: raw, stepId: '' };
  return { agentId: raw.slice(0, splitAt), stepId: raw.slice(splitAt + 2) };
}
const WORKER_ROLES = ['planner', 'setup', 'developer', 'verifier', 'tester', 'reviewer'];
const WORKER_ROLE_LABELS = {
  planner: 'Planner',
  setup: 'Setup',
  developer: 'Developer',
  verifier: 'Verifier',
  tester: 'Tester',
  reviewer: 'Reviewer'
};
const DEFAULT_BASE_WORKER_POOL = {
  planner: 6,
  setup: 2,
  developer: 4,
  verifier: 2,
  tester: 2,
  reviewer: 2
};
function normalizeWorkerCount(value, fallback = 0){
  const n = Number(value);
  if (!Number.isFinite(n)) return fallback;
  return Math.max(0, Math.min(64, Math.floor(n)));
}
function normalizeBaseWorkerPool(raw){
  const src = raw && typeof raw === 'object' ? raw : {};
  const next = {};
  WORKER_ROLES.forEach((role) => {
    next[role] = normalizeWorkerCount(src[role], DEFAULT_BASE_WORKER_POOL[role]);
  });
  return next;
}
function ensureBaseWorkerPool(base){
  const next = normalizeBaseWorkerPool(base?.workerPool || {});
  if (base && typeof base === 'object') base.workerPool = next;
  return next;
}
function workerId(role, idx){
  return `${role}-${idx + 1}`;
}
function workflowById(workflowId){
  return (state.workflows || []).find((wf) => String(wf?.id || '') === String(workflowId || '')) || null;
}
function workflowRequiredRoles(workflowId){
  const wf = workflowById(workflowId);
  if (!wf || !Array.isArray(wf.steps)) return [];
  const seen = new Set();
  const roles = [];
  wf.steps.forEach((step) => {
    const role = String(step?.agent || '').trim().toLowerCase();
    if (!role || seen.has(role)) return;
    seen.add(role);
    roles.push(role);
  });
  return roles;
}
function resolveRunBaseId(run){
  const ctx = parseContext(run);
  const ctxBaseId = String(ctx.baseId || '').trim();
  if (ctxBaseId) return ctxBaseId;
  const linked = (state.featureBuildings || []).find((fb) => String(fb?.runId || '') === String(run?.id || ''));
  if (linked?.baseId) return String(linked.baseId);
  const repo = baseRepoKey(String(ctx.baseRepoPath || ctx.repoPath || getRepo(run) || ''));
  const byRepo = (state.bases || []).find((b) => baseRepoKey(String(b?.repo || '')) === repo);
  return byRepo?.id ? String(byRepo.id) : '';
}
function stageLabel(stepId){
  const raw = String(stepId || '').trim();
  if (!raw) return 'Unknown';
  const words = raw.replace(/[_-]+/g, ' ').split(/\s+/).filter(Boolean);
  return words.map((w) => w.slice(0, 1).toUpperCase() + w.slice(1)).join(' ');
}
function baseStageKanban(baseId){
  const id = String(baseId || '');
  const runs = (state.runs || []).filter((run) => String(resolveRunBaseId(run)) === id);
  const order = [];
  const seen = new Set();
  const buckets = new Map();
  runs.forEach((run) => {
    const steps = Array.isArray(run?.steps) ? [...run.steps] : [];
    steps.sort((a, b) => Number(a?.step_index || 0) - Number(b?.step_index || 0));
    steps.forEach((step) => {
      const key = String(step?.step_id || step?.id || '').trim().toLowerCase() || 'unknown';
      if (!seen.has(key)) {
        seen.add(key);
        order.push(key);
      }
      if (!buckets.has(key)) buckets.set(key, { waiting: 0, done: 0 });
      const bucket = buckets.get(key);
      const status = normalizeRunStatus(step?.status || '');
      if (NON_TERMINAL_RUN_STATUSES.has(status)) bucket.waiting += 1;
      else if (status === 'done' || status === 'skipped' || status === 'completed' || status === 'success') bucket.done += 1;
    });
  });
  return order.map((key) => ({
    key,
    label: stageLabel(key),
    waiting: Number(buckets.get(key)?.waiting || 0),
    done: Number(buckets.get(key)?.done || 0),
  }));
}
function getBusyWorkersByBase(){
  const byBase = new Map();
  (state.runs || []).forEach((run) => {
    const status = normalizeRunStatus(run?.status || '');
    if (!NON_TERMINAL_RUN_STATUSES.has(status)) return;
    const baseId = resolveRunBaseId(run);
    if (!baseId) return;
    if (!byBase.has(baseId)) byBase.set(baseId, { roleBusy: {}, roleBusyIds: {} });
    const entry = byBase.get(baseId);
    const ctx = parseContext(run);
    const assignments = (ctx.workerAssignments && typeof ctx.workerAssignments === 'object')
      ? ctx.workerAssignments
      : null;
    if (assignments) {
      Object.entries(assignments).forEach(([roleRaw, workerRaw]) => {
        const role = String(roleRaw || '').toLowerCase();
        if (!WORKER_ROLES.includes(role)) return;
        const worker = String(workerRaw || '').trim();
        entry.roleBusy[role] = Number(entry.roleBusy[role] || 0) + 1;
        if (!entry.roleBusyIds[role]) entry.roleBusyIds[role] = new Set();
        if (worker) entry.roleBusyIds[role].add(worker);
      });
      return;
    }
    const required = workflowRequiredRoles(run.workflow_id);
    required.forEach((role) => {
      if (!WORKER_ROLES.includes(role)) return;
      entry.roleBusy[role] = Number(entry.roleBusy[role] || 0) + 1;
    });
  });
  return byBase;
}
function deriveBaseWorkerStats(base){
  const pool = ensureBaseWorkerPool(base);
  const byBase = getBusyWorkersByBase();
  const busy = byBase.get(String(base?.id || '')) || { roleBusy: {}, roleBusyIds: {} };
  return WORKER_ROLES.map((role) => {
    const total = Number(pool[role] || 0);
    const busyCount = Math.min(total, Number(busy.roleBusy?.[role] || 0));
    const idle = Math.max(0, total - busyCount);
    return { role, total, busy: busyCount, idle };
  });
}
function allocateWorkersForBase(base, workflowId){
  const pool = ensureBaseWorkerPool(base);
  const byBase = getBusyWorkersByBase();
  const busy = byBase.get(String(base?.id || '')) || { roleBusy: {}, roleBusyIds: {} };
  const requiredRoles = workflowRequiredRoles(workflowId);
  const assignments = {};
  const missing = [];
  requiredRoles.forEach((role) => {
    if (!WORKER_ROLES.includes(role)) return;
    const total = Number(pool[role] || 0);
    const busyCount = Number(busy.roleBusy?.[role] || 0);
    const busyIds = new Set([...(busy.roleBusyIds?.[role] || [])]);
    const remainder = Math.max(0, Math.min(total, busyCount) - busyIds.size);
    for (let i = 0; i < remainder; i++) busyIds.add(workerId(role, i));
    let chosen = '';
    for (let i = 0; i < total; i++) {
      const candidate = workerId(role, i);
      if (busyIds.has(candidate)) continue;
      chosen = candidate;
      break;
    }
    if (!chosen) missing.push(role);
    else assignments[role] = chosen;
  });
  return { assignments, missing };
}
function findBaseForFeature(draft){
  if (!draft) return null;
  const byId = String(draft.baseId || '').trim();
  if (byId) {
    const exact = (state.bases || []).find((b) => String(b?.id || '') === byId);
    if (exact) return exact;
  }
  const repo = baseRepoKey(String(draft.repo || ''));
  const candidates = (state.bases || []).filter((b) => baseRepoKey(String(b?.repo || '')) === repo);
  if (!candidates.length) return null;
  const center = centerPointFor('feature', Number(draft.x || 0), Number(draft.y || 0));
  return candidates.reduce((best, base) => {
    const c = centerPointFor('base', Number(base.x || 0), Number(base.y || 0));
    const d = Math.hypot(c.x - center.x, c.y - center.y);
    if (!best || d < best.dist) return { base, dist: d };
    return best;
  }, null)?.base || candidates[0];
}
function canDeleteSelection(){
  const s = state.selected;
  if (!s) return false;
  if (s.type === 'belt') return true;
  if (s.type === 'base') return s.data?.source === 'custom';
  if (s.type === 'baseDraft') return true;
  if (s.type === 'building') return true;
  return false;
}
function panelToolbar(title, subtitle = ''){
  const sub = subtitle ? `<div class="notice">${esc(subtitle)}</div>` : '<div class="notice"></div>';
  const del = canDeleteSelection() ? '<button id="panelDeleteBtn" class="panel-delete">Delete</button>' : '';
  return `
    <div class="panel-toolbar">
      <h3>${esc(title)}</h3>
      ${sub}
      ${del}
    </div>
  `;
}
function wirePanelDeleteButton(){
  const btn = document.getElementById('panelDeleteBtn');
  if (!btn) return;
  btn.addEventListener('click', () => deleteSelectedStructure());
}
function renderDefaultActionPanel(){
  const panel = document.getElementById('actionPanel');
  if (!panel) return;
  const live = state.live || {};
  panel.dataset.mode = 'default';
  panel.dataset.featureId = '';
  panel.innerHTML = `
    ${panelToolbar(`Command Console ${COMMAND_CONSOLE_VERSION}`, state.placementMode ? `Placement: ${state.placementMode}` : 'Idle')}
    <div class="kv"><strong>Active runs:</strong> ${Number(live.activeRunCount || 0)}</div>
    <div class="kv"><strong>Pending runs:</strong> ${Number(live.pendingRunCount || 0)}</div>
    <div class="kv"><strong>Running agents:</strong> ${Number(live.runningAgentCount || 0)}</div>
    <div class="notice">Place Base, Feature, Research, Warehouse, University, Library, or Power Plant structures from the cards below.</div>
  `;
  wirePanelDeleteButton();
}
function isResearchKind(kind){
  return kind === 'research' || kind === 'university';
}
function isStorageKind(kind){
  return kind === 'warehouse' || kind === 'library' || kind === 'power';
}
function isLibraryLike(building){
  if (!building || typeof building !== 'object') return false;
  if (building.kind === 'library') return true;
  if (building.kind !== 'warehouse') return false;
  const variant = String(building.variant || '').toLowerCase();
  const id = String(building.id || '').toLowerCase();
  return variant === 'library' || id.startsWith('library-');
}
function isInventoryStorageKind(kind){
  return kind === 'warehouse' || kind === 'library';
}
function hoverSummaryForBuilding(b){
  if (!b) return '';
  if (b.kind === 'base') return 'Base command hub';
  if (b.kind === 'feature') {
    const timeoutStep = timedOutStepForRun(b.run);
    if (timeoutStep) return `BAD • timeout on ${prettyStepName(timeoutStep.step_id || 'step')} • ${Math.round(Number(b.progress || 0))}%`;
    return `${prettyStatus(getDisplayRunStatus(b.run, b.phase, b.runId || b.id || 'draft'))} • ${Math.round(Number(b.progress || 0))}%`;
  }
  if (b.kind === 'university') return 'University campus';
  if (b.kind === 'research') return 'Research lab';
  if (isLibraryLike(b)) return `${Array.isArray(b.items) ? b.items.length : 0} archived entries`;
  if (b.kind === 'power') return `${Array.isArray(state.diag?.cron?.jobs) ? state.diag.cron.jobs.length : Number(state.diag?.cron?.matchingCount || 0)} cron jobs`;
  if (b.kind === 'warehouse') return `${Array.isArray(b.items) ? b.items.length : 0} stored items`;
  if (b.kind === 'run') return prettyStatus(getDisplayRunStatus(b.run, b.phase, b.runId || b.id || 'waiting'));
  return '';
}
function showBuildingHoverCard(building, clientX, clientY){
  const card = document.getElementById('buildingHoverCard');
  if (!card || !building) return;
  let title = 'Structure';
  if (building.kind === 'feature') title = 'Feature Forge';
  else if (building.kind === 'university') title = 'University';
  else if (building.kind === 'research') title = 'Research Lab';
  else if (isLibraryLike(building)) title = 'Library';
  else if (building.kind === 'power') title = 'Power Plant P';
  else if (building.kind === 'warehouse') title = 'Warehouse';
  else if (building.kind === 'run') title = 'Run Structure';
  card.innerHTML = `<strong>${esc(title)}</strong><span>${esc(hoverSummaryForBuilding(building))}</span>`;
  card.style.display = 'block';
  const pad = 10;
  const rect = card.getBoundingClientRect();
  let x = clientX + 14;
  let y = clientY - (rect.height + 14);
  if (x + rect.width > window.innerWidth - pad) x = window.innerWidth - rect.width - pad;
  if (x < pad) x = pad;
  if (y < pad) y = clientY + 14;
  if (y + rect.height > window.innerHeight - pad) y = window.innerHeight - rect.height - pad;
  card.style.left = `${Math.round(x)}px`;
  card.style.top = `${Math.round(y)}px`;
}
function hideBuildingHoverCard(){
  const card = document.getElementById('buildingHoverCard');
  if (!card) return;
  card.style.display = 'none';
}
function isLibraryBuilding(building){
  return isLibraryLike(building);
}
function formatBytes(bytes){
  const n = Number(bytes || 0);
  if (!Number.isFinite(n) || n < 1024) return `${Math.max(0, Math.floor(n))} B`;
  if (n < 1024 * 1024) return `${(n / 1024).toFixed(1)} KB`;
  return `${(n / (1024 * 1024)).toFixed(1)} MB`;
}
function renderStoragePanelForBuilding(warehouseId){
  const wh = (state.warehouseBuildings || []).find((it) => String(it.id) === String(warehouseId || ''))
    || (state.selected?.type === 'building' && isStorageKind(state.selected?.data?.kind) ? state.selected.data : null);
  if (wh && wh.kind === 'power') {
    closeLibraryModal();
    void renderPowerPlantPanel(String(wh.id || warehouseId || ''));
    return;
  }
  if (wh && isLibraryBuilding(wh)) {
    void renderLibraryPanel(String(wh.id || warehouseId || ''));
    return;
  }
  closeLibraryModal();
  renderWarehousePanel(warehouseId);
}
function closeLibraryModal(){
  const modal = document.getElementById('libraryModal');
  if (modal) modal.hidden = true;
}
function preloadRtsSprites(){
  if (spritesPreloadPromise) return spritesPreloadPromise;
  const load = (url) => new Promise((resolve) => {
    const img = new Image();
    img.decoding = 'async';
    img.loading = 'eager';
    img.onload = () => resolve(true);
    img.onerror = () => resolve(false);
    img.src = url;
  });
  spritesPreloadPromise = Promise.all(RTS_SPRITE_URLS.map(load)).catch(() => []);
  return spritesPreloadPromise;
}
async function json(url){
  const r = await fetch(url);
  const data = await r.json();
  if (!r.ok) throw new Error(data?.error || `request_failed:${r.status}`);
  return data;
}
async function postJson(url, body){
  const r = await fetch(url, {
    method:'POST',
    headers:{ 'Content-Type':'application/json' },
    body: JSON.stringify(body)
  });
  const data = await r.json();
  if (!r.ok || data?.ok === false) throw new Error(data?.error || data?.next || `request_failed:${r.status}`);
  return data;
}

function snapshotPersistableState(){
  return {
    camera: state.camera || { x:0, y:0 },
    hiddenBelts: (state.hiddenBelts && typeof state.hiddenBelts === 'object') ? state.hiddenBelts : {},
    // Persist research/warehouse payloads (plans/items) via rts_layout_entities.
    researchBuildings: Array.isArray(state.researchBuildings)
      ? state.researchBuildings.map((rb) => normalizeResearchBuilding(rb))
      : [],
    warehouseBuildings: Array.isArray(state.warehouseBuildings)
      ? state.warehouseBuildings.map((wb) => normalizeWarehouseBuilding(wb))
      : []
  };
}

function queuePersist(){
  if (state.persistTimer) clearTimeout(state.persistTimer);
  state.persistTimer = setTimeout(async () => {
    const payload = snapshotPersistableState();
    try {
      await postJson('/api/rts/state', { state: payload });
    } catch {}
  }, 250);
}

async function persistNow(){
  if (state.persistTimer) {
    clearTimeout(state.persistTimer);
    state.persistTimer = null;
  }
  const payload = snapshotPersistableState();
  try {
    await postJson('/api/rts/state', { state: payload });
  } catch {}
}

function resolveDraggedEntityPosition(drag){
  if (!drag) return null;
  if (drag.type === 'base') {
    const b = (state.customBases || []).find((x) => x.id === drag.id)
      || (state.bases || []).find((x) => x.id === drag.id);
    return b ? { x:Number(b.x)||0, y:Number(b.y)||0 } : null;
  }
  if (drag.type === 'feature') {
    const f = (state.featureBuildings || []).find((x) => x.id === drag.id) || (state.buildings || []).find((x) => x.id === drag.id);
    return f ? { x:Number(f.x)||0, y:Number(f.y)||0 } : null;
  }
  if (drag.type === 'research') {
    const r = (state.researchBuildings || []).find((x) => x.id === drag.id) || (state.buildings || []).find((x) => x.id === drag.id);
    return r ? { x:Number(r.x)||0, y:Number(r.y)||0 } : null;
  }
  if (drag.type === 'university') {
    const u = (state.researchBuildings || []).find((x) => x.id === drag.id) || (state.buildings || []).find((x) => x.id === drag.id);
    return u ? { x:Number(u.x)||0, y:Number(u.y)||0 } : null;
  }
  if (drag.type === 'warehouse') {
    const w = (state.warehouseBuildings || []).find((x) => x.id === drag.id) || (state.buildings || []).find((x) => x.id === drag.id);
    return w ? { x:Number(w.x)||0, y:Number(w.y)||0 } : null;
  }
  if (drag.type === 'library') {
    const l = (state.warehouseBuildings || []).find((x) => x.id === drag.id) || (state.buildings || []).find((x) => x.id === drag.id);
    return l ? { x:Number(l.x)||0, y:Number(l.y)||0 } : null;
  }
  if (drag.type === 'power') {
    const p = (state.warehouseBuildings || []).find((x) => x.id === drag.id) || (state.buildings || []).find((x) => x.id === drag.id);
    return p ? { x:Number(p.x)||0, y:Number(p.y)||0 } : null;
  }
  if (drag.type === 'run') {
    const p = state.runLayoutOverrides?.[drag.runId || drag.id];
    if (p) return { x:Number(p.x)||0, y:Number(p.y)||0 };
    const b = (state.buildings || []).find((x) => x.id === drag.id);
    return b ? { x:Number(b.x)||0, y:Number(b.y)||0 } : null;
  }
  return null;
}

async function persistDraggedEntityPosition(drag){
  const pos = resolveDraggedEntityPosition(drag);
  if (!pos) return;
  const entityType = drag.type === 'base'
    ? 'base'
    : (drag.type === 'feature' ? 'feature'
      : (drag.type === 'research' || drag.type === 'university' ? 'research'
        : (drag.type === 'warehouse' || drag.type === 'library' || drag.type === 'power' ? 'warehouse' : 'run')));
  await postJson('/api/rts/layout/position', {
    entityType,
    entityId: drag.id,
    runId: drag.runId || null,
    repoPath: drag.repoPath || null,
    worktreePath: drag.worktreePath || null,
    x: pos.x,
    y: pos.y
  });
}

async function hydratePersistedState(){
  let persisted = null;
  try {
    const r = await json('/api/rts/state');
    persisted = r?.state || null;
  } catch {}
  if (!persisted || typeof persisted !== 'object') return;
  if (Array.isArray(persisted.customBases)) {
    const byRepo = new Map();
    for (const raw of persisted.customBases) {
      const b = raw && typeof raw === 'object' ? raw : {};
      const repo = baseRepoKey(String(b.repo || ''));
      const id = String(b.id || `base-${repo}`);
      byRepo.set(repo, {
        ...b,
        id,
        repo,
        source: 'custom',
        workerPool: normalizeBaseWorkerPool(b.workerPool || {}),
        x: Number(b.x || 0),
        y: Number(b.y || 0),
      });
    }
    state.customBases = Array.from(byRepo.values());
  }
  if (Array.isArray(persisted.featureBuildings)) {
    const seen = new Set();
    state.featureBuildings = persisted.featureBuildings
      .map(normalizeFeatureDraft)
      .filter((fb) => {
      const runKey = fb?.runId ? `run:${fb.runId}` : "";
      const key = runKey || `draft:${fb?.id || ""}:${fb?.repo || ""}:${fb?.x || 0}:${fb?.y || 0}`;
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  }
  if (Array.isArray(persisted.researchBuildings)) {
    state.researchBuildings = persisted.researchBuildings
      .map(normalizeResearchBuilding)
      .filter((rb) => !!rb.repo);
  }
  if (Array.isArray(persisted.warehouseBuildings)) {
    state.warehouseBuildings = persisted.warehouseBuildings
      .map(normalizeWarehouseBuilding);
  }
  if (persisted.runLayoutOverrides && typeof persisted.runLayoutOverrides === 'object') state.runLayoutOverrides = persisted.runLayoutOverrides;
  if (persisted.hiddenBelts && typeof persisted.hiddenBelts === 'object') state.hiddenBelts = persisted.hiddenBelts;
  if (persisted.camera && typeof persisted.camera === 'object') {
    state.camera = {
      x: Number(persisted.camera.x) || 0,
      y: Number(persisted.camera.y) || 0
    };
  }
  if (!state.featureBuildings.length && Array.isArray(persisted.setupDrafts)) {
    state.featureBuildings = persisted.setupDrafts
      .map((d) => normalizeFeatureDraft({ ...d, phase: 'draft' }));
  }
  // Do not restore selection across sessions; always boot into clean neutral view.
  state.selected = null;
}
function parseContext(run){ try { return JSON.parse(run.context || '{}'); } catch { return {}; } }
function extractPrUrl(run){
  if (!run || typeof run !== 'object') return null;
  const candidates = [
    run.task,
    run.context,
    ...(run.steps || []).map((s) => `${String(s?.step_id || '')}\n${String(s?.output || '')}`)
  ].join('\n');
  const re = /https?:\/\/[^\s)]+\/pull\/[0-9]+/ig;
  let last = null;
  let m = re.exec(candidates);
  while (m) {
    last = m[0];
    m = re.exec(candidates);
  }
  return last || null;
}
function runProgress(run){
  const steps = run.steps || [];
  if (!steps.length) return 0;
  const done = steps.filter(s => s.status === 'done' || s.status === 'skipped').length;
  return Math.round((done / steps.length) * 100);
}
function getRepo(run){
  const ctx = parseContext(run);
  // Prefer original base repo path so run/feature buildings stay attached
  // to the user-placed movable base instead of worktree-derived auto bases.
  const raw = ctx.baseRepoPath || ctx.repoPath || ctx.repo || ctx.repository || ctx.worktreePath || '';
  return normalizePathKey(raw).replace(/-feature-[^/]+$/i, '');
}
function stableToken(input){
  const raw = String(input || '');
  let h = 2166136261;
  for (let i = 0; i < raw.length; i++) {
    h ^= raw.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return (h >>> 0).toString(36).slice(0, 6).padStart(6, '0');
}
function getWorktreeDefault(repo, seed = ''){
  const clean = String(repo || '').split('/').pop() || 'repo';
  const token = stableToken(`${normalizePathKey(repo)}:${String(seed || 'default')}`);
  return `../${clean}-feature-${token}`;
}
function normalizePathKey(raw){
  return String(raw || '').trim().replace(/\\/g, '/').replace(/\/+$/, '');
}
function isAbsolutePathKey(key){
  return key.startsWith('/') || /^[A-Za-z]:\//.test(key);
}
function baseRepoKey(pathValue){
  let key = normalizePathKey(pathValue || '');
  if (key === 'workspace-repo' && state.runtime?.cwd) key = normalizePathKey(state.runtime.cwd);
  if (!isAbsolutePathKey(key) && state.runtime?.cwd) key = absolutizePath(key, state.runtime.cwd);
  if (!key) return 'workspace-repo';
  return key.replace(/-feature-[^/]+$/i, '') || 'workspace-repo';
}
function absolutizePath(pathValue, repoPath){
  const key = normalizePathKey(pathValue);
  if (!key) return '';
  if (isAbsolutePathKey(key)) return key;
  let base = normalizePathKey(repoPath);
  if (!isAbsolutePathKey(base) && state.runtime?.cwd) base = normalizePathKey(state.runtime.cwd);
  if (!base) return key;
  const stack = base.split('/');
  for (const part of key.split('/')) {
    if (!part || part === '.') continue;
    if (part === '..') {
      if (stack.length > 1) stack.pop();
      continue;
    }
    stack.push(part);
  }
  return stack.join('/');
}
function inferPortFromPath(pathValue){
  const key = normalizePathKey(pathValue);
  if (!key) return null;
  if (/\/antfarm$/.test(key)) return 3333;
  const featureMatch = key.match(/antfarm-feature-(\d+)/i);
  if (featureMatch) {
    const n = Number(featureMatch[1] || 0);
    if (Number.isFinite(n)) return 3400 + (n % 400);
  }
  return null;
}
function getPortForPath(pathValue){
  const key = normalizePathKey(pathValue);
  if (!key) return null;
  const mapped = Number(state.portByPath?.[key]);
  if (Number.isFinite(mapped) && mapped > 0 && mapped < 65536) return mapped;
  return inferPortFromPath(key);
}
function setPortForPath(pathValue, portValue){
  const key = normalizePathKey(pathValue);
  const port = Number(portValue);
  if (!key) return;
  if (!Number.isFinite(port) || port < 1 || port > 65535) return;
  state.portByPath = {
    ...(state.portByPath || {}),
    [key]: Math.floor(port),
  };
}
function nextSpreadPort(startPort){
  const start = Number(startPort);
  let candidate = Number.isFinite(start) && start > 0 ? Math.floor(start) : 3334;
  if (candidate < 1024) candidate = 3334;
  const used = new Set();
  Object.values(state.portByPath || {}).forEach((p) => {
    const n = Number(p);
    if (Number.isFinite(n) && n > 0) used.add(Math.floor(n));
  });
  (state.featureBuildings || []).forEach((fb) => {
    const n = Number(fb?.port || 0);
    if (Number.isFinite(n) && n > 0) used.add(Math.floor(n));
  });
  const stride = 10;
  let loops = 0;
  while (used.has(candidate) && candidate <= 65535 && loops < 7000) {
    candidate += stride;
    loops += 1;
  }
  if (candidate > 65535) {
    candidate = 3334;
    while (used.has(candidate) && candidate <= 65535) candidate += 1;
  }
  return candidate > 65535 ? 3334 : candidate;
}
function pathLabel(pathValue){
  const key = normalizePathKey(pathValue);
  if (!key) return 'base';
  const featureMatch = key.match(/antfarm-feature-(\d+)/i);
  if (featureMatch) return `feature-${featureMatch[1]}`;
  if (/\/antfarm$/.test(key)) return 'master';
  const parts = key.split('/');
  return parts[parts.length - 1] || 'base';
}
function runtimeLink(portValue){
  const port = Number(portValue);
  if (!Number.isFinite(port) || port < 1 || port > 65535) return '<span class="badge">unassigned</span>';
  const host = `100.115.134.49:${Math.floor(port)}`;
  const href = `http://${host}`;
  return `<a class="pr-link" href="${href}" target="_blank" rel="noopener noreferrer">${host}</a>`;
}
function factionFromWorkflow(id){ return (id || 'neutral').split(/[^a-z0-9]+/i)[0] || 'neutral'; }
function inferUnitModel(agentId, run){
  // TODO(server): expose per-agent runtime model metadata from run execution payload.
  const ctx = parseContext(run);
  const modelMap = ctx.agentModels || ctx.modelsByAgent || ctx.models;
  if (modelMap && typeof modelMap === 'object' && modelMap[agentId]) return String(modelMap[agentId]);
  if (ctx.model && typeof ctx.model === 'string') return ctx.model;
  return 'unknown';
}

const GRID_SIZE = 22;
const FOOTPRINTS = {
  base: { cols: 10, rows: 7, spriteW: 264, spriteH: 168 },
  feature: { cols: 6, rows: 4, spriteW: 186, spriteH: 98 },
  research: { cols: 6, rows: 4, spriteW: 186, spriteH: 98 },
  warehouse: { cols: 6, rows: 4, spriteW: 186, spriteH: 98 },
  university: { cols: 6, rows: 4, spriteW: 186, spriteH: 98 },
  library: { cols: 6, rows: 4, spriteW: 186, spriteH: 98 },
  power: { cols: 6, rows: 4, spriteW: 186, spriteH: 98 },
  run: { cols: 6, rows: 4, spriteW: 186, spriteH: 98 }
};

function buildingFootprint(kind){
  const key = (kind === 'base' || kind === 'feature' || kind === 'research' || kind === 'warehouse' || kind === 'university' || kind === 'library' || kind === 'power' || kind === 'run') ? kind : 'run';
  const fp = FOOTPRINTS[key];
  return {
    cols: fp.cols,
    rows: fp.rows,
    w: fp.cols * GRID_SIZE,
    h: fp.rows * GRID_SIZE,
    spriteW: fp.spriteW,
    spriteH: fp.spriteH
  };
}

function centerPointFor(kind, x, y){
  const fp = buildingFootprint(kind);
  return { x: Number(x || 0) + (fp.w / 2), y: Number(y || 0) + (fp.h / 2) };
}

function worldDepth(y, bias = 100000){
  return Math.max(1, bias + Math.floor(Number(y) || 0));
}

function getLiveAgentEntry(runId, agentId, stepId = ''){
  const list = state.live?.activeAgents || [];
  const step = String(stepId || '').trim();
  return list.find((a) => {
    if (a.runId !== runId || a.agentId !== agentId) return false;
    if (!step) return true;
    return String(a.stepId || '') === step;
  }) || null;
}

function runTargetCenterMap(){
  const targets = new Map();
  (state.buildings || []).forEach((b) => {
    const rid = b.run?.id || b.runId || (b.kind === 'run' ? b.id : '');
    if (!rid) return;
    const kind = b.kind === 'feature'
      ? 'feature'
      : (b.kind === 'university' ? 'university' : (b.kind === 'research' ? 'research' : 'run'));
    const centerRaw = centerPointFor(kind, b.x, b.y);
    const center = { x: centerRaw.x, y: centerRaw.y, kind: b.kind };
    const current = targets.get(rid);
    if (!current || (current.kind === 'run' && b.kind === 'feature')) targets.set(rid, center);
  });
  return targets;
}

function activeRunAgentMap(){
  const m = new Map();
  const list = Array.isArray(state.live?.activeAgents) ? state.live.activeAgents : [];
  list.forEach((entry) => {
    if (!entry?.runId || !entry?.agentId) return;
    if (!m.has(entry.runId)) m.set(entry.runId, entry.agentId);
  });
  return m;
}

function renderLiveConsole(){
  const panel = document.getElementById('livePanel');
  const live = state.live || {};
  const diag = state.diag || {};
  const agents = Array.isArray(live.activeAgents) ? live.activeAgents : [];
  const stamp = live.ts ? new Date(live.ts).toLocaleTimeString([], { hour:'2-digit', minute:'2-digit', second:'2-digit' }) : '--:--:--';
  const cronCount = Number(diag?.cron?.matchingCount || 0);
  const workerTotal = Number(live?.workerTotal || cronCount || 0);
  const blocked = diag?.likelyBlockedReason ? `WARN ${diag.likelyBlockedReason}` : '';
  const runtimeLine = state.runtime?.cwd ? `${state.runtime.cwd} @ :${state.runtime.port || 3333}` : '';
  const deployWaiting = Number(live.pendingRunCount || 0);
  const deployDisabled = state.liveDeployInFlight || deployWaiting <= 0;
  const runGlobalCronDisabled = state.liveDeployInFlight || deployWaiting <= 0;
  const lines = agents.length
    ? agents.slice(0, 120).map((a) => {
      const age = typeof a.ageSec === 'number' ? String(a.ageSec).padStart(3, ' ') : ' --';
      const status = a.stale ? 'STALE' : 'RUN';
      const agentShort = String(a.agentId || '').split('/').pop() || a.agentId || 'unknown';
      const runShort = String(a.runId || '').slice(0, 8);
      return `${status} ${age}s  ${runShort}  ${agentShort}  ${a.stepId || 'step'}`;
    }).join('\n')
    : 'IDLE  no active agents';

  if (panel) {
    panel.innerHTML = `
      <h3>Live Agent TTY</h3>
      <div class="cli-panel">
        <div class="cli-head">
          <span>RUN ${live.activeRunCount || 0} | <button id="runGlobalCronBtn" class="agent-restart" ${runGlobalCronDisabled ? 'disabled' : ''} style="padding:0 6px;line-height:1.5">WAIT ${live.pendingRunCount || 0}</button> | AGENT ${live.runningAgentCount || 0} | WORKERS ${workerTotal}</span>
          <button id="deployWaitingBtn" class="agent-restart" ${deployDisabled ? 'disabled' : ''}>deploy</button>
          <span>${esc(stamp)}</span>
        </div>
        <div class="cli-body">${esc(lines)}</div>
      </div>
      <div class="notice" style="margin-top:6px">Source: Antfarm DB step state on this machine. ${esc(blocked)}${state.liveDeployNotice ? ` ${esc(state.liveDeployNotice)}` : ''}</div>
      ${runtimeLine ? `<div class="notice" style="margin-top:4px">Serving: ${esc(runtimeLine)}</div>` : ''}
    `;
  }
  if (!state.selected) renderDefaultActionPanel();
  const deployBtn = document.getElementById('deployWaitingBtn');
  const runGlobalCronBtn = document.getElementById('runGlobalCronBtn');
  deployBtn?.addEventListener('click', async () => {
    if (state.liveDeployInFlight) return;
    state.liveDeployInFlight = true;
    state.liveDeployNotice = `Deploying up to ${deployWaiting} waiting run(s)...`;
    renderLiveConsole();
    try {
      const result = await postJson('/api/rts/deploy', { maxRuns: deployWaiting });
      state.liveDeployNotice = result.kicked > 0
        ? `Deploy kicked ${result.kicked}/${result.attempted} run(s).`
        : 'No pending runs were kickable.';
      await refreshRuntimeState();
      rebuildScene();
      renderSelection();
    } catch (err) {
      state.liveDeployNotice = `Deploy failed: ${err.message || err}`;
    } finally {
      state.liveDeployInFlight = false;
      renderLiveConsole();
    }
  });
  runGlobalCronBtn?.addEventListener('click', async () => {
    if (state.liveDeployInFlight) return;
    state.liveDeployInFlight = true;
    state.liveDeployNotice = 'Queued clicked. Triggering global cron tick...';
    renderLiveConsole();
    try {
      const result = await postJson('/api/rts/cron/run-global', {});
      const attempted = Number(result?.attempted || 0);
      const nudged = Number(result?.nudged || 0);
      state.liveDeployNotice = nudged > 0
        ? `Global cron tick queued for ${nudged}/${attempted} antfarm job(s).`
        : 'No enabled antfarm cron jobs found.';
      await refreshRuntimeState();
      rebuildScene();
      renderSelection();
    } catch (err) {
      state.liveDeployNotice = `Global cron tick failed: ${err.message || err}`;
    } finally {
      state.liveDeployInFlight = false;
      renderLiveConsole();
    }
  });
}

function runsSignature(runs){
  return (runs || [])
    // Avoid rebuilding the entire world on every heartbeat timestamp update.
    .map((r) => `${r.id}:${r.status || ''}:${r.workflow_id || ''}`)
    .sort()
    .join('|');
}

function getRunStatusOverride(runId){
  const key = String(runId || '');
  if (!key) return '';
  const row = state.runStatusOverrides?.[key];
  if (!row || typeof row !== 'object') return '';
  const until = Number(row.until || 0);
  if (!until || Date.now() > until) {
    delete state.runStatusOverrides[key];
    return '';
  }
  return String(row.status || '').trim().toLowerCase();
}

function getDisplayRunStatus(run, fallbackPhase = '', runId = ''){
  const rid = String(run?.id || runId || '');
  const optimistic = getRunStatusOverride(rid);
  if (optimistic) return optimistic;
  return String(run?.status || fallbackPhase || '').trim().toLowerCase();
}

function markRunRelaunched(runId){
  const rid = String(runId || '').trim();
  if (!rid) return;
  state.runStatusOverrides[rid] = { status: 'running', until: Date.now() + 45000 };
  const run = (state.runs || []).find((r) => String(r.id) === rid);
  if (run) run.status = 'running';
  (state.featureBuildings || []).forEach((fb) => {
    if (String(fb?.runId || '') === rid) fb.phase = 'running';
  });
}

async function boot(){
  // Warm sprite decode/cache so first placement/select doesn't pop in images.
  void preloadRtsSprites();
  await hydratePersistedState();
  state.workflows = await json('/api/workflows');
  try { state.localRepos = await json('/api/local-repos'); } catch { state.localRepos = []; }
  try { state.runtime = (await json('/api/rts/runtime')).runtime || null; } catch { state.runtime = null; }
  await refreshRuntimeState(true);
  rebuildScene();
  renderLiveConsole();
  startLiveStream();
  queuePersist();
}

async function refreshRuntimeState(throwOnError = false){
  try {
    const [runs, liveRes, diagRes] = await Promise.all([
      json('/api/runs'),
      json('/api/rts/live'),
      json('/api/rts/diag?workflow=feature-dev')
    ]);
    const nextSig = runsSignature(runs);
    const runsChanged = nextSig !== state.runSig;
    state.runs = runs;
    state.runSig = nextSig;
    if (state.runStatusOverrides && typeof state.runStatusOverrides === 'object') {
      Object.keys(state.runStatusOverrides).forEach((runId) => {
        const liveRun = runs.find((r) => String(r.id) === runId);
        const liveStatus = String(liveRun?.status || '').trim().toLowerCase();
        if (!liveRun || ['running', 'retrying', 'queued', 'claimed', 'in_progress', 'done', 'completed', 'success'].includes(liveStatus)) {
          delete state.runStatusOverrides[runId];
        }
      });
    }
    state.live = (liveRes && liveRes.live) ? liveRes.live : state.live;
    state.diag = (diagRes && diagRes.diag) ? diagRes.diag : state.diag;
    return runsChanged;
  } catch (err) {
    if (throwOnError) throw err;
    return false;
  }
}

function startLiveStream(){
  if (state.liveStream) {
    try { state.liveStream.close(); } catch {}
    state.liveStream = null;
  }
  try {
    const es = new EventSource('/api/rts/live/stream');
    es.addEventListener('live', (evt) => {
      try {
        const payload = JSON.parse(evt.data || '{}');
        state.live = payload || state.live;
        if (Number(state.live?.runningAgentCount || 0) > 0) {
          ensureMotionLoop();
          renderUnitsLiveState();
        } else {
          renderUnitsLiveState();
        }
        renderLiveConsole();
      } catch {}
    });
    es.onerror = () => {
      try { es.close(); } catch {}
      state.liveStream = null;
    };
    state.liveStream = es;
  } catch {
    state.liveStream = null;
  }
}

function rebuildScene(){
  updateCameraVisuals();
  const customByRepo = new Map();
  (state.customBases || []).forEach((cb) => {
    if (!cb?.repo) return;
    const repoKey = baseRepoKey(cb.repo);
    customByRepo.set(repoKey, { ...cb, repo: repoKey, workerPool: normalizeBaseWorkerPool(cb.workerPool || {}) });
  });

  const runsByRepo = new Map();
  (state.runs || []).forEach((run) => {
    const rawRepo = normalizePathKey(getRepo(run));
    if (!rawRepo) return;
    const repo = baseRepoKey(rawRepo);
    if (!runsByRepo.has(repo)) runsByRepo.set(repo, []);
    runsByRepo.get(repo).push(run);
  });

  const mergedBases = [];
  const usedCustomBaseIds = new Set();
  let autoIndex = 0;
  runsByRepo.forEach((runs, repo) => {
    const existingCustom = customByRepo.get(repo);
    if (existingCustom) {
      const resolvedPort = Number(existingCustom.port) || getPortForPath(existingCustom.repo) || 3333;
      if (existingCustom.repo) setPortForPath(existingCustom.repo, resolvedPort);
      mergedBases.push({
        ...existingCustom,
        runs,
        source:'custom',
        port: resolvedPort,
        portLabel: pathLabel(existingCustom.repo),
        workerPool: normalizeBaseWorkerPool(existingCustom.workerPool || {})
      });
      usedCustomBaseIds.add(existingCustom.id);
      return;
    }
    const resolvedPort = getPortForPath(repo) || 3333;
    setPortForPath(repo, resolvedPort);
    mergedBases.push({
      id:`base-run-${autoIndex}`,
      x: 90 + (autoIndex%3)*320,
      y: 80 + Math.floor(autoIndex/3)*220,
      repo,
      runs,
      source:'run',
      port: resolvedPort,
      portLabel: pathLabel(repo),
      workerPool: normalizeBaseWorkerPool({})
    });
    autoIndex += 1;
  });

  (state.customBases || []).forEach((cb) => {
    if (usedCustomBaseIds.has(cb.id)) return;
    const repoKey = baseRepoKey(cb.repo);
    const resolvedPort = Number(cb.port) || getPortForPath(repoKey) || 3333;
    if (repoKey) setPortForPath(repoKey, resolvedPort);
    mergedBases.push({
      ...cb,
      repo: repoKey,
      runs: cb.runs || [],
      source:'custom',
      port: resolvedPort,
      portLabel: pathLabel(repoKey),
      workerPool: normalizeBaseWorkerPool(cb.workerPool || {})
    });
  });

  const buildings = [];
  const units = [];
  const runBaseCenters = new Map();
  const baseFp = buildingFootprint('base');
  const runFp = buildingFootprint('run');
  const persistedFeatureByRunId = new Map(
    (state.featureBuildings || [])
      .filter((f) => f?.runId)
      .map((f) => [f.runId, f])
  );
  const linkedFeatureRunIds = new Set([...persistedFeatureByRunId.keys()]);
  const runDefaultLayout = new Map();
  mergedBases.forEach(base => {
    (base.runs || []).forEach((run, ri) => {
      const runCtx = parseContext(run);
      const runWorktreePath = String(runCtx.worktreePath || '');
      const runRepoPath = baseRepoKey(String(runCtx.baseRepoPath || runCtx.repoPath || getRepo(run) || ''));
      const basePort = Number(base.port) || getPortForPath(base.repo || '') || 3333;
      const runPort = getPortForPath(runWorktreePath) || getPortForPath(runRepoPath) || (basePort + 1);
      runBaseCenters.set(run.id, centerPointFor('base', base.x, base.y));
      const defaultX = Number(base.x + GRID_SIZE + (ri%2)*(runFp.w + GRID_SIZE));
      const defaultY = Number(base.y + baseFp.h + GRID_SIZE + Math.floor(ri/2)*(runFp.h + GRID_SIZE));
      runDefaultLayout.set(run.id, { x: defaultX, y: defaultY });
      if (!linkedFeatureRunIds.has(run.id)) {
        const override = state.runLayoutOverrides?.[run.id];
        buildings.push({
          id: run.id,
          kind: 'run',
          run,
          x: Number(override?.x ?? defaultX),
          y: Number(override?.y ?? defaultY),
          progress: runProgress(run),
          prUrl: extractPrUrl(run),
          repo: runRepoPath,
          worktreePath: runWorktreePath,
          port: runPort,
          portLabel: pathLabel(runWorktreePath || runRepoPath)
        });
      }

      const faction = factionFromWorkflow(run.workflow_id);
      const agents = [...new Set((run.steps||[]).map(s => s.agent_id).filter(Boolean))];
      agents.forEach((agent, ai) => {
        units.push({
          id: `${run.id}-u-${ai}`,
          runId: run.id,
          label: agent.split('/').pop(),
          full: agent,
          faction,
          model: inferUnitModel(agent, run),
          x: base.x + baseFp.w + 26 + (ai*24),
          y: base.y + 10 + (ri*24),
          homeX: base.x + baseFp.w + 26 + (ai*24),
          homeY: base.y + 10 + (ri*24),
          baseCenterX: base.x + (baseFp.w / 2),
          baseCenterY: base.y + (baseFp.h / 2),
          subagents: 2 + (ai % 3)
        });
      });
    });
  });
  (state.researchBuildings || []).forEach((rb) => {
    const rbKind = rb.kind === 'university' ? 'university' : 'research';
    const repoPath = baseRepoKey(String(rb.repo || ''));
    const researchCenter = centerPointFor(rbKind, Number(rb.x || 0), Number(rb.y || 0));
    const linkedBase = (mergedBases || []).reduce((best, base) => {
      const c = centerPointFor('base', Number(base.x || 0), Number(base.y || 0));
      const d = Math.hypot(c.x - researchCenter.x, c.y - researchCenter.y);
      if (!best || d < best.dist) return { base, dist: d };
      return best;
    }, null)?.base || null;
    buildings.push({
      ...rb,
      kind: rbKind,
      repo: repoPath,
      run: null,
      runId: null,
      progress: 0,
      phase: 'idle',
      worktreePath: String(rb.worktreePath || repoPath || ''),
      port: Number(getPortForPath(repoPath || '')) || 3333,
      portLabel: pathLabel(repoPath || '')
    });
    if (linkedBase) {
      units.push({
        id: `research-${rb.id}-u-0`,
        runId: `research:${rb.id}`,
        label: 'cephalon',
        full: `research/cephalon/${rb.id}`,
        faction: 'research',
        model: 'antfarm/research',
        x: Number(linkedBase.x || 0) + baseFp.w + 22,
        y: Number(linkedBase.y || 0) + 22,
        homeX: Number(linkedBase.x || 0) + baseFp.w + 22,
        homeY: Number(linkedBase.y || 0) + 22,
        baseCenterX: Number(linkedBase.x || 0) + (baseFp.w / 2),
        baseCenterY: Number(linkedBase.y || 0) + (baseFp.h / 2),
        subagents: 1
      });
    }
  });

  (state.warehouseBuildings || []).forEach((wb) => {
    const wbKind = wb.kind === 'library' ? 'library' : (wb.kind === 'power' ? 'power' : 'warehouse');
    const repoPath = baseRepoKey(String(wb.repo || ''));
    buildings.push({
      ...wb,
      kind: wbKind,
      repo: repoPath,
      run: null,
      runId: null,
      progress: 0,
      phase: 'idle',
      worktreePath: String(wb.worktreePath || repoPath || ''),
      port: Number(getPortForPath(repoPath || '')) || 3333,
      portLabel: pathLabel(repoPath || '')
    });
  });

  (state.featureBuildings || []).forEach((fb) => {
    const repoPath = baseRepoKey(String(fb.repo || ''));
    const resolvedBase = findBaseForFeature(fb);
    const baseId = String(fb.baseId || resolvedBase?.id || '');
    const worktreePathRaw = String(fb.worktreePath || '');
    const worktreePath = absolutizePath(worktreePathRaw, repoPath);
    const run = fb.runId
      ? (state.runs || []).find(r => r.id === fb.runId)
      : (state.runs || []).find((r) => {
          const ctx = parseContext(r);
          const runWt = absolutizePath(String(ctx.worktreePath || ''), String(ctx.baseRepoPath || ctx.repoPath || repoPath));
          return !!runWt && !!worktreePath && runWt === worktreePath;
        });
    const fallbackPort = getPortForPath(worktreePath || '') || getPortForPath(repoPath || '') || 3334;
    const port = Number(fb.port) || fallbackPort;
    if (worktreePath) setPortForPath(worktreePath, port);
    buildings.push({
      ...fb,
      kind: 'feature',
      baseId,
      run,
      runId: run?.id || fb.runId || null,
      progress: run ? runProgress(run) : 0,
      prUrl: run ? extractPrUrl(run) : null,
      phase: run ? (run.status || 'running') : 'draft',
      port,
      worktreePath: worktreePath || worktreePathRaw,
      portLabel: pathLabel(worktreePath || repoPath || '')
    });
  });

  state.bases = mergedBases;
  state.buildings = buildings;
  const runTargets = runTargetCenterMap();
  const activeMap = activeRunAgentMap();
  const nowSec = Date.now() / 1000;
  state.units = units.map((u, idx) => {
    const target = runTargets.get(u.runId);
    const activeAgent = activeMap.get(u.runId);
    const isActive = !!target && activeAgent === u.full;
    if (!isActive || !target) return u;
    const homeX = Number(u.homeX ?? u.x);
    const homeY = Number(u.homeY ?? u.y);
    const tx = Number(target.x);
    const ty = Number(target.y);
    const cycle = 0.8 + (((u.runId.charCodeAt(0) || 7) + idx) % 5) * 0.07;
    const phase = nowSec * cycle;
    const pingPong = (Math.sin(phase) + 1) / 2;
    const x = homeX + (tx - homeX) * pingPong;
    const y = homeY + (ty - homeY) * pingPong;
    return { ...u, x, y, moving: true };
  });

  if (state.selected?.type === 'building') {
    const fresh = state.buildings.find(b => b.id === state.selected.data.id);
    if (fresh) state.selected = { type:'building', data:fresh };
    else state.selected = null;
  } else if (state.selected?.type === 'unit') {
    const fresh = state.units.find(u => u.runId === state.selected.data.runId && u.full === state.selected.data.full);
    if (fresh) state.selected = { type:'unit', data:fresh };
    else state.selected = null;
  } else if (state.selected?.type === 'baseDraft') {
    const fresh = (state.baseDrafts || []).find(d => d.id === state.selected.data.id);
    if (fresh) state.selected = { type:'baseDraft', data:fresh };
    else state.selected = null;
  } else if (state.selected?.type === 'base') {
    const fresh = state.bases.find(b => b.id === state.selected.data.id);
    if (fresh) state.selected = { type:'base', data:fresh };
    else state.selected = null;
  }

  renderWorld();
  if (Number(state.live?.runningAgentCount || 0) > 0) ensureMotionLoop();
  if (state.selected) renderSelection();
  if (state.selected?.type === 'building' && !isEditingActionPanel()) {
    if (state.selected.data?.kind === 'feature') renderRunSetupPanel(state.selected.data.id);
    else if (state.selected.data?.kind === 'research') renderResearchLabPanel(state.selected.data.id);
    else if (state.selected.data?.kind === 'university') renderUniversityPanel(state.selected.data.id);
    else if (isStorageKind(state.selected.data?.kind)) renderStoragePanelForBuilding(state.selected.data.id);
  }
}

function renderUnitsMotionFrame(){
  const runTargets = runTargetCenterMap();
  const activeMap = activeRunAgentMap();
  const nowSec = Date.now() / 1000;

  state.units.forEach((u, idx) => {
    const node = document.querySelector(`.unit[data-run-id="${CSS.escape(u.runId)}"][data-agent-id="${CSS.escape(u.full)}"]`);
    if (!node) return;
    const target = runTargets.get(u.runId);
    const activeAgent = activeMap.get(u.runId);
    const isActive = !!target && activeAgent === u.full;
    const homeX = Number(u.homeX ?? u.x);
    const homeY = Number(u.homeY ?? u.y);
    let ux = Number(u.x);
    let uy = Number(u.y);
    if (isActive && target) {
      const tx = Number(target.x);
      const ty = Number(target.y);
      const cycle = 0.8 + (((u.runId.charCodeAt(0) || 7) + idx) % 5) * 0.07;
      const phase = nowSec * cycle;
      const pingPong = (Math.sin(phase) + 1) / 2;
      ux = homeX + (tx - homeX) * pingPong;
      uy = homeY + (ty - homeY) * pingPong;
    }
    const p = worldToScreen(ux, uy);
    node.style.left = `${p.x}px`;
    node.style.top = `${p.y}px`;
    node.style.zIndex = String(worldDepth(uy, 2000));
    node.classList.toggle('moving', isActive);
  });
}

function ensureMotionLoop(){
  if (state.motionTimer) return;
  state.motionTimer = setInterval(() => {
    if (Number(state.live?.runningAgentCount || 0) <= 0) {
      clearInterval(state.motionTimer);
      state.motionTimer = null;
      return;
    }
    renderUnitsMotionFrame();
  }, 120);
}

function setPlacement(mode){
  state.placementMode = mode;
  const notice = document.getElementById('placementNotice');
  if (notice) {
    if (!mode) notice.textContent = 'IDLE';
    else if (mode === 'base') notice.textContent = 'BASE';
    else if (mode === 'university') notice.textContent = 'UNIVERSITY';
    else if (mode === 'library') notice.textContent = 'LIBRARY';
    else if (mode === 'power') notice.textContent = 'POWER';
    else if (mode === 'research') notice.textContent = 'LAB';
    else if (mode === 'warehouse') notice.textContent = 'WAREHOUSE';
    else notice.textContent = 'FORGE';
  }
  document.querySelectorAll('.palette-card[data-building]').forEach((card) => {
    card.classList.toggle('active', card.getAttribute('data-building') === mode);
  });
  if (!mode) hidePlacementGhost();
  if (!state.selected) renderDefaultActionPanel();
}

function placeBaseAt(x,y){
  const draft = {
    id:`clone-draft-${Date.now()}`,
    x,y,
    repoUrl:'',
    targetPath:'',
    existingRepoPath:'',
    port: 3333,
    label:'New Base',
    committed:false
  };
  state.baseDrafts.push(draft);
  state.selected = { type:'baseDraft', data:draft };
  queuePersist();
  rebuildScene();
  renderSelection();
  renderBaseCloneForm(draft);
}

function nearBase(x,y){
  let best = null;
  (state.bases || []).forEach((b) => {
    const center = centerPointFor('base', b.x, b.y);
    const d = Math.hypot(center.x - x, center.y - y);
    if (d > 240) return;
    if (!best || d < best.dist) best = { base: b, dist: d };
  });
  return best?.base || null;
}

function nearWarehouse(x,y){
  let best = null;
  (state.warehouseBuildings || []).forEach((w) => {
    const center = centerPointFor('warehouse', Number(w.x || 0), Number(w.y || 0));
    const d = Math.hypot(center.x - x, center.y - y);
    if (d > 240) return;
    if (!best || d < best.dist) best = { warehouse: w, dist: d };
  });
  return best?.warehouse || null;
}

function nearResearch(x,y){
  let best = null;
  (state.researchBuildings || []).forEach((r) => {
    if (r.kind !== 'research') return;
    const center = centerPointFor('research', Number(r.x || 0), Number(r.y || 0));
    const d = Math.hypot(center.x - x, center.y - y);
    if (d > 240) return;
    if (!best || d < best.dist) best = { research: r, dist: d };
  });
  return best?.research || null;
}
function nearUniversity(x,y){
  let best = null;
  (state.researchBuildings || []).forEach((u) => {
    if (u.kind !== 'university') return;
    const center = centerPointFor('university', Number(u.x || 0), Number(u.y || 0));
    const d = Math.hypot(center.x - x, center.y - y);
    if (d > 240) return;
    if (!best || d < best.dist) best = { university: u, dist: d };
  });
  return best?.university || null;
}

function nearFeatureBuilding(x,y){
  const byId = new Map();
  (state.buildings || []).filter((b) => b.kind === 'feature').forEach((f) => {
    if (f?.id) byId.set(String(f.id), f);
  });
  (state.featureBuildings || []).forEach((f) => {
    if (f?.id && !byId.has(String(f.id))) byId.set(String(f.id), f);
  });
  let best = null;
  byId.forEach((f) => {
    const center = centerPointFor('feature', Number(f.x || 0), Number(f.y || 0));
    const d = Math.hypot(center.x - x, center.y - y);
    if (d > 240) return;
    if (!best || d < best.dist) best = { feature: f, dist: d };
  });
  return best?.feature || null;
}

function resolveFeaturePlacementAnchor(x,y){
  const base = nearBase(x, y);
  const warehouse = nearWarehouse(x, y);
  const feature = nearFeatureBuilding(x, y);
  const candidates = [];
  if (base) {
    const c = centerPointFor('base', Number(base.x || 0), Number(base.y || 0));
    candidates.push({ type: 'base', data: base, dist: Math.hypot(c.x - x, c.y - y) });
  }
  if (warehouse) {
    const c = centerPointFor('warehouse', Number(warehouse.x || 0), Number(warehouse.y || 0));
    candidates.push({ type: 'warehouse', data: warehouse, dist: Math.hypot(c.x - x, c.y - y) });
  }
  if (feature) {
    const c = centerPointFor('feature', Number(feature.x || 0), Number(feature.y || 0));
    candidates.push({ type: 'feature', data: feature, dist: Math.hypot(c.x - x, c.y - y) });
  }
  if (!candidates.length) return null;
  candidates.sort((a, b) => a.dist - b.dist);
  return candidates[0];
}

function placeFeatureAt(x,y,prefillPrompt = '', forcedRepoPath = ''){
  dbg('placeFeatureAt:start', { x, y, hasPrompt: !!prefillPrompt, forcedRepoPath });
  const center = centerPointFor('feature', x, y);
  const anchor = resolveFeaturePlacementAnchor(center.x, center.y);
  if (!anchor) {
    dbg('placeFeatureAt:blocked_no_anchor', { x, y, center });
    alert('Feature Request structures must be placed near a Base, Warehouse, or another Feature.');
    return null;
  }
  const anchorData = anchor.data || {};
  const inheritedRepo = String(anchorData.repo || '');
  const inheritedWorktree = String(anchorData.worktreePath || inheritedRepo || '');
  const inferredBase = anchor.type === 'base'
    ? anchorData
    : (anchor.type === 'feature'
      ? (findBaseForFeature(anchorData) || nearBase(center.x, center.y))
      : ((state.bases || []).find((b) => String(b.id || '') === String(anchorData.baseId || '')) || nearBase(center.x, center.y)));
  const repoPath = forcedRepoPath || inheritedRepo || inferredBase?.repo || 'unlinked-repo';
  const basePort = Number(anchorData.port)
    || getPortForPath(inheritedWorktree || repoPath || '')
    || getPortForPath(repoPath || '')
    || Number(inferredBase?.port || 0)
    || 3333;
  const featureId = `feature-${Date.now()}`;
  const featureBuilding = {
    id: featureId,
    kind:'feature',
    phase:'draft',
    committed:false,
    runId: null,
    baseId: String(inferredBase?.id || anchorData.baseId || ''),
    x, y,
    repo: repoPath,
    worktreePath: getWorktreeDefault(repoPath || 'repo', featureId),
    port: nextSpreadPort(Number(basePort || 3333) + 1),
    prompt: String(prefillPrompt || ''),
    workerAssignments: {},
    empty: false
  };
  state.featureBuildings.push(featureBuilding);
  void postJson('/api/rts/layout/position', {
    entityType: 'feature',
    entityId: featureBuilding.id,
    runId: null,
    repoPath: featureBuilding.repo || null,
    worktreePath: featureBuilding.worktreePath || null,
    x: featureBuilding.x,
    y: featureBuilding.y,
    allowCreate: true,
    payload: {
      baseId: String(featureBuilding.baseId || ''),
      workerAssignments: featureBuilding.workerAssignments || {},
      prompt: String(featureBuilding.prompt || '')
    }
  }).catch(() => {});
  state.selected = { type:'building', data:featureBuilding };
  state.recentFeaturePlacementUntil = Date.now() + 600;
  dbg('placeFeatureAt:created', { id: featureBuilding.id, repo: featureBuilding.repo, x: featureBuilding.x, y: featureBuilding.y });
  queuePersist();
  rebuildScene();
  renderSelection();
  renderRunSetupPanel(featureBuilding.id);
  // Ensure freshly placed factories stay selected and show prompt/run UI
  // after any trailing pointer/click events.
  queueMicrotask(() => {
    const current = (state.buildings || []).find((b) => b.id === featureBuilding.id && b.kind === 'feature')
      || (state.featureBuildings || []).find((b) => b.id === featureBuilding.id);
    if (!current) return;
    state.selected = { type:'building', data:current };
    renderSelection();
    renderRunSetupPanel(featureBuilding.id);
    setFeatureMode(true);
  });
  return featureBuilding;
}

function placeResearchAt(x,y,kind = 'research'){
  const normalizedKind = String(kind || '').toLowerCase() === 'university' ? 'university' : 'research';
  const center = centerPointFor('research', x, y);
  const base = nearBase(center.x, center.y);
  if (!base) {
    alert(normalizedKind === 'university'
      ? 'Universities must be placed near a Base.'
      : 'Research Labs must be placed near a Base.');
    return;
  }
  const researchBuilding = {
    id: `${normalizedKind}-${Date.now()}`,
    kind: normalizedKind,
    x, y,
    repo: base.repo || 'unlinked-repo',
    worktreePath: base.repo || 'unlinked-repo',
    plans: [],
    baseId: base.id
  };
  state.researchBuildings.push(researchBuilding);
  void postJson('/api/rts/layout/position', {
    entityType: 'research',
    entityId: researchBuilding.id,
    runId: null,
    repoPath: researchBuilding.repo || null,
    worktreePath: researchBuilding.worktreePath || null,
    x: researchBuilding.x,
    y: researchBuilding.y,
    allowCreate: true,
    payload: { kind: normalizedKind }
  }).catch(() => {});
  state.selected = { type:'building', data:researchBuilding };
  queuePersist();
  rebuildScene();
  renderSelection();
  if (normalizedKind === 'university') renderUniversityPanel(researchBuilding.id);
  else renderResearchLabPanel(researchBuilding.id);
}

function placeUniversityAt(x,y){
  placeResearchAt(x, y, 'university');
}

function placeWarehouseAt(x,y,kind = 'warehouse'){
  const rawKind = String(kind || '').toLowerCase();
  const normalizedKind = rawKind === 'library' ? 'library' : (rawKind === 'power' ? 'power' : 'warehouse');
  const center = centerPointFor('warehouse', x, y);
  const anchor = (normalizedKind === 'library' || normalizedKind === 'power')
    ? nearUniversity(center.x, center.y)
    : nearResearch(center.x, center.y);
  if (!anchor) {
    if (normalizedKind === 'library') alert('Libraries must be placed near a University.');
    else if (normalizedKind === 'power') alert('Power Plants must be placed near a University.');
    else alert('Warehouses must be placed near a Research Lab.');
    return;
  }
  const repoPath = String(anchor.repo || 'unlinked-repo');
  const warehouseBuilding = {
    id: `${normalizedKind}-${Date.now()}`,
    kind: normalizedKind,
    x, y,
    repo: repoPath,
    worktreePath: String(anchor.worktreePath || repoPath),
    items: [],
    baseId: String(anchor.baseId || '')
  };
  state.warehouseBuildings.push(warehouseBuilding);
  void postJson('/api/rts/layout/position', {
    entityType: 'warehouse',
    entityId: warehouseBuilding.id,
    runId: null,
    repoPath: warehouseBuilding.repo || null,
    worktreePath: warehouseBuilding.worktreePath || null,
    x: warehouseBuilding.x,
    y: warehouseBuilding.y,
    allowCreate: true,
    payload: { kind: normalizedKind }
  }).catch(() => {});
  state.selected = { type:'building', data:warehouseBuilding };
  queuePersist();
  rebuildScene();
  renderSelection();
  if (normalizedKind === 'library') void renderLibraryPanel(warehouseBuilding.id);
  else if (normalizedKind === 'power') void renderPowerPlantPanel(warehouseBuilding.id);
  else renderWarehousePanel(warehouseBuilding.id);
}

function placeLibraryAt(x,y){
  placeWarehouseAt(x, y, 'library');
}
function placePowerAt(x,y){
  placeWarehouseAt(x, y, 'power');
}

function structureMarkup(kind, variant = ''){
  if (kind === 'base') {
    return `<img class="building-sprite" src="/rts-sprites/base_sprite-20260212a.png?v=20260212a" alt="" />`;
  }
  if (kind === 'feature') {
    return `<img class="building-sprite" src="/rts-sprites/feature_factory_sprite.png?v=20260212v" alt="" />`;
  }
  if (kind === 'university' || (kind === 'research' && String(variant || '') === 'university')) {
    return `<img class="building-sprite" src="/rts-sprites/university_sprite-20260212a.png?v=20260212a" alt="" />`;
  }
  if (kind === 'research') {
    return `<img class="building-sprite" src="/rts-sprites/research_lab_sprite.png?v=20260212v" alt="" />`;
  }
  if (kind === 'library' || (kind === 'warehouse' && String(variant || '') === 'library')) {
    return `<img class="building-sprite" src="/rts-sprites/library_sprite-20260212a.png?v=20260212a" alt="" />`;
  }
  if (kind === 'power' || (kind === 'warehouse' && String(variant || '') === 'power')) {
    return `<img class="building-sprite" src="/rts-sprites/power_sprite-20260212a.png?v=20260212a" alt="" />`;
  }
  if (kind === 'warehouse') {
    return `<img class="building-sprite" src="/rts-sprites/warehouse_sprite.png?v=20260212v" alt="" />`;
  }
  return `<img class="building-sprite" src="/rts-sprites/feature_factory_sprite.png?v=20260212v" alt="" />`;
}

function snapPlacement(kind, worldX, worldY){
  const { w, h } = buildingFootprint(kind);
  return {
    x: Math.round((worldX - (w / 2)) / GRID_SIZE) * GRID_SIZE,
    y: Math.round((worldY - (h / 2)) / GRID_SIZE) * GRID_SIZE
  };
}

function hidePlacementGhost(){
  placementLayerEl.innerHTML = '';
}

function setFeatureMode(active){
  state.featureMode = !!active;
  const layout = document.querySelector('.layout');
  if (!layout) return;
  layout.classList.toggle('feature-mode', state.featureMode);
}

function worldToScreen(x, y){
  return { x, y };
}

function screenToWorld(clientX, clientY){
  // Use the non-transformed wrapper for pointer math; the world layer itself is camera-transformed.
  const rect = worldWrapEl.getBoundingClientRect();
  const sx = clientX - rect.left;
  const sy = clientY - rect.top;
  return { sx, sy, x: sx + state.camera.x, y: sy + state.camera.y };
}

function updateCameraVisuals(){
  worldWrapEl.style.setProperty('--cam-x', `${state.camera.x}px`);
  worldWrapEl.style.setProperty('--cam-y', `${state.camera.y}px`);
}

function showPlacementGhost(kind, worldX, worldY){
  if (!kind) return hidePlacementGhost();
  const point = snapPlacement(kind, worldX, worldY);
  const screen = worldToScreen(point.x, point.y);
  const center = centerPointFor(kind, point.x, point.y);
  const invalid = kind === 'feature'
    ? !resolveFeaturePlacementAnchor(center.x, center.y)
    : ((kind === 'research' || kind === 'university')
      ? !nearBase(center.x, center.y)
      : (kind === 'warehouse'
        ? !nearResearch(center.x, center.y)
        : (kind === 'library' || kind === 'power' ? !nearUniversity(center.x, center.y) : false)));
  const className = kind === 'base' ? 'base' : 'building';
  const fp = buildingFootprint(kind);
  placementLayerEl.innerHTML = `
    <div class="entity ${className} placement-ghost ${invalid ? 'invalid' : ''}" style="left:${screen.x}px;top:${screen.y}px;z-index:${worldDepth(point.y, 1000)};--footprint-w:${fp.w}px;--footprint-h:${fp.h}px;--sprite-w:${fp.spriteW}px;--sprite-h:${fp.spriteH}px">
      <div class="iso-core">${structureMarkup(kind)}</div>
    </div>
  `;
}

function localPointInWorld(event){
  return screenToWorld(event.clientX, event.clientY);
}

function edgeAutoPan(clientX, clientY, margin = 36, speed = 18){
  // Use wrapper bounds; worldEl is camera-transformed and skews edge detection.
  const rect = worldWrapEl.getBoundingClientRect();
  if (!rect || rect.width <= 0 || rect.height <= 0) return false;
  let moved = false;
  if (clientX < rect.left + margin) { state.camera.x -= speed; moved = true; }
  else if (clientX > rect.right - margin) { state.camera.x += speed; moved = true; }
  if (clientY < rect.top + margin) { state.camera.y -= speed; moved = true; }
  else if (clientY > rect.bottom - margin) { state.camera.y += speed; moved = true; }
  if (moved) updateCameraVisuals();
  return moved;
}

function isEditingActionPanel(){
  const panel = document.getElementById('actionPanel');
  const active = document.activeElement;
  if (!panel || !active || !panel.contains(active)) return false;
  return ['INPUT','TEXTAREA','SELECT'].includes(active.tagName);
}

function updateCustomBasePosition(id, x, y){
  const i = state.customBases.findIndex(b => b.id === id);
  if (i >= 0) {
    state.customBases[i] = { ...state.customBases[i], x, y, source: 'custom' };
    return;
  }
  const base = (state.bases || []).find((b) => String(b.id) === String(id));
  if (!base) return;
  state.customBases.push({
    id: String(base.id || id),
    repo: String(base.repo || ''),
    x,
    y,
    source: 'custom',
    port: Number(base.port) || getPortForPath(base.repo || '') || 3333,
    portLabel: base.portLabel || pathLabel(base.repo || ''),
    runs: Array.isArray(base.runs) ? base.runs : []
  });
}

function removeBaseDraftById(id){
  state.baseDrafts = (state.baseDrafts || []).filter(d => d.id !== id);
}

function updateFeaturePosition(id, x, y){
  const i = state.featureBuildings.findIndex(b => b.id === id);
  if (i >= 0) {
    state.featureBuildings[i] = { ...state.featureBuildings[i], x, y };
    return;
  }
  const b = (state.buildings || []).find((it) => it.id === id && it.kind === 'feature');
  const runId = b?.runId || b?.run?.id || '';
  if (runId) updateRunBuildingPosition(runId, x, y);
}

function updateResearchPosition(id, x, y){
  const i = state.researchBuildings.findIndex((b) => b.id === id);
  if (i < 0) return;
  state.researchBuildings[i] = { ...state.researchBuildings[i], x, y };
}
function updateUniversityPosition(id, x, y){
  updateResearchPosition(id, x, y);
}

function updateWarehousePosition(id, x, y){
  const i = state.warehouseBuildings.findIndex((b) => b.id === id);
  if (i < 0) return;
  state.warehouseBuildings[i] = { ...state.warehouseBuildings[i], x, y };
}
function updateLibraryPosition(id, x, y){
  updateWarehousePosition(id, x, y);
}
function updatePowerPosition(id, x, y){
  updateWarehousePosition(id, x, y);
}

function updateRunBuildingPosition(id, x, y){
  state.runLayoutOverrides = {
    ...(state.runLayoutOverrides || {}),
    [id]: { x, y }
  };
}

function updateBaseDraftPosition(id, x, y){
  const i = state.baseDrafts.findIndex(d => d.id === id);
  if (i < 0) return;
  state.baseDrafts[i] = { ...state.baseDrafts[i], x, y };
}

function cancelActiveFeatureDraft(){
  const selected = state.selected;
  if (selected?.type !== 'building' || selected?.data?.kind !== 'feature') return false;
  if (selected.data.committed || selected.data.runId) return false;
  void postJson('/api/rts/layout/delete', { entityType: 'feature', entityId: selected.data.id }).catch(() => {});
  state.featureBuildings = (state.featureBuildings || []).filter((b) => b.id !== selected.data.id);
  state.selected = null;
  queuePersist();
  rebuildScene();
  renderSelection();
  renderRunSetupPanel(null);
  return true;
}

function clearSelectedEntity(){
  if (!state.selected) return;
  state.selected = null;
  setFeatureMode(false);
  queuePersist();
  renderSelection();
  renderRunSetupPanel(null);
  refreshSelectionVisuals();
  hideBuildingHoverCard();
}

async function deleteSelectedStructure(){
  const s = state.selected;
  if (!s) return;
  if (s.type === 'belt') {
    const beltId = String(s.data?.id || '');
    if (!beltId) return;
    state.hiddenBelts = {
      ...(state.hiddenBelts || {}),
      [beltId]: true
    };
    state.selected = null;
    queuePersist();
    rebuildScene();
    renderSelection();
    renderRunSetupPanel(null);
    return;
  }
  if (s.type === 'base' && s.data?.source === 'custom') {
    try {
      await postJson('/api/rts/layout/delete', { entityType: 'base', entityId: s.data.id });
    } catch (err) {
      alert(`Delete failed: ${err.message || err}`);
      return;
    }
    state.customBases = state.customBases.filter(b => b.id !== s.data.id);
    state.selected = null;
    queuePersist();
    rebuildScene();
    renderSelection();
    renderRunSetupPanel(null);
    return;
  }
  if (s.type === 'baseDraft') {
    removeBaseDraftById(s.data.id);
    state.selected = null;
    queuePersist();
    rebuildScene();
    renderSelection();
    renderRunSetupPanel(null);
    return;
  }
  if (s.type === 'building' && s.data?.kind === 'feature') {
    if (s.data?.runId) {
      try {
        await postJson('/api/rts/building/delete', { runId: s.data.runId });
        state.runs = await json('/api/runs');
      } catch (err) {
        alert(`Delete failed: ${err.message || err}`);
        return;
      }
      if (state.runLayoutOverrides && typeof state.runLayoutOverrides === 'object') {
        delete state.runLayoutOverrides[s.data.runId];
      }
    } else {
      try {
        await postJson('/api/rts/layout/delete', { entityType: 'feature', entityId: s.data.id });
      } catch (err) {
        alert(`Delete failed: ${err.message || err}`);
        return;
      }
    }
    state.featureBuildings = state.featureBuildings.filter(b => b.id !== s.data.id);
    state.selected = null;
    queuePersist();
    rebuildScene();
    renderSelection();
    renderRunSetupPanel(null);
    return;
  }
  if (s.type === 'building' && isResearchKind(s.data?.kind)) {
    try {
      await postJson('/api/rts/layout/delete', { entityType: 'research', entityId: s.data.id });
    } catch (err) {
      alert(`Delete failed: ${err.message || err}`);
      return;
    }
    state.researchBuildings = (state.researchBuildings || []).filter((b) => b.id !== s.data.id);
    state.selected = null;
    queuePersist();
    rebuildScene();
    renderSelection();
    renderRunSetupPanel(null);
    return;
  }
  if (s.type === 'building' && isStorageKind(s.data?.kind)) {
    try {
      await postJson('/api/rts/layout/delete', { entityType: 'warehouse', entityId: s.data.id });
    } catch (err) {
      alert(`Delete failed: ${err.message || err}`);
      return;
    }
    state.warehouseBuildings = (state.warehouseBuildings || []).filter((b) => b.id !== s.data.id);
    state.selected = null;
    queuePersist();
    rebuildScene();
    renderSelection();
    renderRunSetupPanel(null);
    return;
  }
  if (s.type === 'building' && s.data?.kind === 'run') {
    try {
      await postJson('/api/rts/building/delete', { runId: s.data.id });
      state.runs = await json('/api/runs');
    } catch (err) {
      alert(`Delete failed: ${err.message || err}`);
      return;
    }
    state.featureBuildings = (state.featureBuildings || []).filter((b) => b.runId !== s.data.id);
    if (state.runLayoutOverrides && typeof state.runLayoutOverrides === 'object') {
      delete state.runLayoutOverrides[s.data.id];
    }
    state.selected = null;
    queuePersist();
    rebuildScene();
    renderSelection();
    renderRunSetupPanel(null);
  }
}

function applyIsoEntity(shell, { className, kind, x, y, z, innerHtml, onClick, entityKey = '' }) {
  const screen = worldToScreen(x, y);
  const fp = buildingFootprint(kind || 'run');
  shell.className = `entity ${className}`;
  if (entityKey) shell.dataset.entityKey = entityKey;
  shell.style.left = `${screen.x}px`;
  shell.style.top = `${screen.y}px`;
  shell.style.zIndex = String(worldDepth(z || y, 1000));
  shell.style.setProperty('--footprint-w', `${fp.w}px`);
  shell.style.setProperty('--footprint-h', `${fp.h}px`);
  shell.style.setProperty('--sprite-w', `${fp.spriteW}px`);
  shell.style.setProperty('--sprite-h', `${fp.spriteH}px`);
  const nextMarkup = `<div class="iso-core">${innerHtml}</div>`;
  if (shell.dataset.markup !== nextMarkup) {
    shell.innerHTML = nextMarkup;
    shell.dataset.markup = nextMarkup;
  }
  shell.onclick = onClick;
  return shell;
}

function upsertIsoEntity({ className, kind, x, y, z, innerHtml, onClick, entityKey = '' }) {
  let shell = entityKey
    ? worldEl.querySelector(`.entity[data-entity-key="${CSS.escape(entityKey)}"]`)
    : null;
  if (!shell) {
    shell = document.createElement('div');
    worldEl.appendChild(shell);
  }
  applyIsoEntity(shell, { className, kind, x, y, z, innerHtml, onClick, entityKey });
  return shell;
}

function refreshSelectionVisuals(){
  document.querySelectorAll('.entity.is-selected, .unit.is-selected, .subunit.is-selected, .rts-path.is-selected')
    .forEach((el) => el.classList.remove('is-selected'));
  if (!state.selected) return;
  if (state.selected.type === 'base') {
    const key = `base:${String(state.selected?.data?.id || '')}`;
    const node = document.querySelector(`.entity[data-entity-key="${CSS.escape(key)}"]`);
    if (node) node.classList.add('is-selected');
    return;
  }
  if (state.selected.type === 'baseDraft') {
    const key = `baseDraft:${String(state.selected?.data?.id || '')}`;
    const node = document.querySelector(`.entity[data-entity-key="${CSS.escape(key)}"]`);
    if (node) node.classList.add('is-selected');
    return;
  }
  if (state.selected.type === 'building') {
    const key = `building:${String(state.selected?.data?.id || '')}`;
    const node = document.querySelector(`.entity[data-entity-key="${CSS.escape(key)}"]`);
    if (node) node.classList.add('is-selected');
    return;
  }
  if (state.selected.type === 'unit' || state.selected.type === 'subunit') {
    const unitKey = `${String(state.selected?.data?.runId || '')}:${String(state.selected?.data?.full || '')}`;
    const unitNode = document.querySelector(`.unit[data-unit-key="${CSS.escape(unitKey)}"]`);
    if (unitNode) unitNode.classList.add('is-selected');
    document.querySelectorAll(`.subunit[data-unit-key="${CSS.escape(unitKey)}"]`)
      .forEach((el) => el.classList.add('is-selected'));
    return;
  }
  if (state.selected.type === 'belt') {
    const key = String(state.selected?.data?.id || '');
    const node = document.querySelector(`.rts-path[data-belt-id="${CSS.escape(key)}"]`);
    if (node) node.classList.add('is-selected');
  }
}

function moveEntityVisual(entityType, entityId, x, y){
  let key = '';
  if (entityType === 'base') key = `base:${String(entityId || '')}`;
  else if (entityType === 'baseDraft') key = `baseDraft:${String(entityId || '')}`;
  else key = `building:${String(entityId || '')}`;
  const node = document.querySelector(`.entity[data-entity-key="${CSS.escape(key)}"]`);
  if (!node) return;
  node.style.left = `${x}px`;
  node.style.top = `${y}px`;
  node.style.zIndex = String(worldDepth(y, 1000));
}

const NON_TERMINAL_RUN_STATUSES = new Set(['pending', 'running', 'retrying', 'queued', 'claimed', 'in_progress', 'waiting']);
const SUCCESS_RUN_STATUSES = new Set(['done', 'completed', 'success']);
const FAILED_RUN_STATUSES = new Set(['failed', 'error', 'canceled', 'cancelled', 'timeout', 'timed_out']);

function normalizeRunStatus(status){
  return String(status || '').trim().toLowerCase();
}

function timedOutStepForRun(run){
  if (!run || !Array.isArray(run.steps)) return null;
  const rs = normalizeRunStatus(run.status || '');
  if (FAILED_RUN_STATUSES.has(rs)) return null;
  const candidates = run.steps
    .filter((step) => Number(step?.retry_count || 0) > 0)
    .sort((a, b) => {
      const at = Date.parse(String(a?.updated_at || ''));
      const bt = Date.parse(String(b?.updated_at || ''));
      const av = Number.isFinite(at) ? at : 0;
      const bv = Number.isFinite(bt) ? bt : 0;
      return bv - av;
    });
  return candidates[0] || null;
}

function normalizeFeatureDraft(raw){
  const src = raw && typeof raw === 'object' ? raw : {};
  const id = String(src.id || `feature-draft-${Date.now()}`);
  const runId = src.runId ? String(src.runId) : '';
  const committed = typeof src.committed === 'boolean'
    ? src.committed
    : !!runId;
  const repo = baseRepoKey(String(src.repo || ''));
  const worktreePath = String(src.worktreePath || getWorktreeDefault(repo || 'repo', id));
  return {
    ...src,
    id,
    kind: 'feature',
    baseId: String(src.baseId || ''),
    repo,
    worktreePath,
    prompt: String(src.prompt || ''),
    workerAssignments: (src.workerAssignments && typeof src.workerAssignments === 'object') ? src.workerAssignments : {},
    runId,
    committed,
    phase: String(src.phase || (committed ? 'running' : 'draft')),
    empty: !!src.empty,
    x: Number(src.x || 0),
    y: Number(src.y || 0),
    port: Number(src.port || 0) || undefined
  };
}

function normalizeResearchBuilding(raw){
  const src = raw && typeof raw === 'object' ? raw : {};
  const repo = baseRepoKey(String(src.repo || ''));
  const kindRaw = String(src.kind || src.variant || 'research').toLowerCase();
  const kind = kindRaw === 'university' ? 'university' : 'research';
  return {
    ...src,
    id: String(src.id || `${kind}-${Date.now()}`),
    kind,
    repo,
    worktreePath: String(src.worktreePath || repo),
    plans: (Array.isArray(src.plans) ? src.plans : []).map((p, idx) => normalizeResearchPlan(p, `lab-plan-${idx + 1}`)),
    baseId: String(src.baseId || ''),
    x: Number(src.x || 0),
    y: Number(src.y || 0)
  };
}

function normalizeWarehouseBuilding(raw){
  const src = raw && typeof raw === 'object' ? raw : {};
  const repo = baseRepoKey(String(src.repo || ''));
  const kindRaw = String(src.kind || src.variant || 'warehouse').toLowerCase();
  const kind = kindRaw === 'library' ? 'library' : (kindRaw === 'power' ? 'power' : 'warehouse');
  return {
    ...src,
    id: String(src.id || `${kind}-${Date.now()}`),
    kind,
    repo,
    worktreePath: String(src.worktreePath || repo),
    items: (Array.isArray(src.items) ? src.items : []).map((p, idx) => normalizeResearchPlan(p, `wh-item-${idx + 1}`)),
    baseId: String(src.baseId || ''),
    x: Number(src.x || 0),
    y: Number(src.y || 0)
  };
}

function normalizeResearchPlan(raw, fallbackId = ''){
  const src = raw && typeof raw === 'object' ? raw : {};
  const typeRaw = String(src.type || 'feature').toLowerCase();
  const type = ['feature', 'bug', 'placeholder'].includes(typeRaw) ? typeRaw : 'feature';
  const dispositionRaw = String(src.disposition || 'OPEN').toUpperCase();
  const disposition = dispositionRaw === 'WONT_FIX' ? 'WONT_FIX' : 'OPEN';
  const id = String(src.id || fallbackId || `plan-${Date.now()}-${Math.random().toString(16).slice(2, 8)}`);
  const evidence = Array.isArray(src.evidence) ? src.evidence.map((x) => String(x || '')).filter(Boolean) : [];
  return {
    ...src,
    id,
    type,
    title: String(src.title || id),
    summary: String(src.summary || ''),
    prompt: String(src.prompt || ''),
    evidence,
    disposition
  };
}

function mergeResearchPlans(existingList, incomingList){
  const byId = new Map();
  const put = (raw) => {
    const plan = normalizeResearchPlan(raw);
    const prev = byId.get(plan.id);
    if (!prev) {
      byId.set(plan.id, plan);
      return;
    }
    const prevDisposition = String(prev.disposition || 'OPEN').toUpperCase();
    const merged = {
      ...prev,
      ...plan,
      disposition: prevDisposition === 'WONT_FIX'
        ? 'WONT_FIX'
        : (String(plan.disposition || prev.disposition || 'OPEN').toUpperCase() === 'WONT_FIX' ? 'WONT_FIX' : 'OPEN')
    };
    byId.set(plan.id, merged);
  };
  (Array.isArray(existingList) ? existingList : []).forEach(put);
  (Array.isArray(incomingList) ? incomingList : []).forEach(put);
  return Array.from(byId.values());
}

function primaryResearchLabForRepo(repoKey){
  const key = baseRepoKey(String(repoKey || ''));
  const labs = (state.researchBuildings || [])
    .filter((rb) => baseRepoKey(String(rb.repo || '')) === key)
    .sort((a, b) => String(a.id || '').localeCompare(String(b.id || '')));
  return labs[0] || null;
}

function primaryWarehouseForRepo(repoKey){
  const key = baseRepoKey(String(repoKey || ''));
  const warehouses = (state.warehouseBuildings || [])
    .filter((wb) => wb.kind !== 'power')
    .filter((wb) => baseRepoKey(String(wb.repo || '')) === key)
    .sort((a, b) => String(a.id || '').localeCompare(String(b.id || '')));
  return warehouses[0] || null;
}

function appendResearchPlans(repoKey, incomingList){
  const lab = primaryResearchLabForRepo(repoKey);
  if (!lab) return [];
  const existing = Array.isArray(lab.plans) ? lab.plans : [];
  const merged = mergeResearchPlans(existing, incomingList);
  lab.plans = merged;
  queuePersist();
  return merged;
}

function planImportanceScore(plan){
  const p = normalizeResearchPlan(plan);
  const typeWeight = p.type === 'bug' ? 3 : (p.type === 'feature' ? 2 : 1);
  const evidenceWeight = Array.isArray(p.evidence) ? Math.min(3, p.evidence.length) : 0;
  return typeWeight * 10 + evidenceWeight;
}

function appendWarehouseItems(repoKey, incomingList){
  const warehouse = primaryWarehouseForRepo(repoKey);
  if (!warehouse) return [];
  const existing = Array.isArray(warehouse.items) ? warehouse.items : [];
  const merged = mergeResearchPlans(existing, incomingList);
  warehouse.items = merged;
  queuePersist();
  return merged;
}

function consumeMostImportantWarehouseItem(repoKey){
  const warehouse = primaryWarehouseForRepo(repoKey);
  if (!warehouse) return null;
  const list = Array.isArray(warehouse.items) ? warehouse.items : [];
  if (!list.length) return null;
  let bestIdx = -1;
  let bestScore = -1;
  list.forEach((raw, idx) => {
    const score = planImportanceScore(raw);
    if (score > bestScore) {
      bestScore = score;
      bestIdx = idx;
    }
  });
  if (bestIdx < 0) return null;
  const plan = normalizeResearchPlan(list[bestIdx]);
  const next = [...list.slice(0, bestIdx), ...list.slice(bestIdx + 1)];
  warehouse.items = next;
  queuePersist();
  return plan;
}

function markResearchPlanWontFix(repoKey, planId){
  const lab = primaryResearchLabForRepo(repoKey);
  const id = String(planId || '');
  if (!lab || !id) return false;
  const existing = Array.isArray(lab.plans) ? lab.plans : [];
  let changed = false;
  const next = existing.map((raw) => {
    const plan = normalizeResearchPlan(raw);
    if (String(plan.id) !== id) return plan;
    if (String(plan.disposition || 'OPEN').toUpperCase() !== 'WONT_FIX') changed = true;
    return { ...plan, disposition: 'WONT_FIX' };
  });
  if (!changed) return false;
  lab.plans = next;
  queuePersist();
  return true;
}

function featureStructureVisualState(building){
  if (!building) return 'draft';
  if (building.empty) return 'draft';
  if (!building.committed || !building.runId) return 'draft';
  if (timedOutStepForRun(building.run)) return 'failed';
  const status = normalizeRunStatus(getDisplayRunStatus(building.run, building.phase, building.runId));
  if (SUCCESS_RUN_STATUSES.has(status)) return 'done';
  if (FAILED_RUN_STATUSES.has(status)) return 'failed';
  if (!status || NON_TERMINAL_RUN_STATUSES.has(status)) return 'in-progress';
  return 'in-progress';
}

function featureStructureClassName(building){
  const visualState = featureStructureVisualState(building);
  if (visualState === 'draft') return 'is-half-transparent';
  if (visualState === 'failed') return 'is-failed';
  return '';
}

function canMarkFeatureEmpty(building){
  if (!building) return false;
  const status = normalizeRunStatus(getDisplayRunStatus(building.run, building.phase, building.runId));
  return !!building.prUrl && SUCCESS_RUN_STATUSES.has(status);
}

function nearestWarehouseForFeature(feature){
  if (!feature) return null;
  const repoKey = baseRepoKey(String(feature.repo || ''));
  const featureCenter = centerPointFor('feature', Number(feature.x || 0), Number(feature.y || 0));
  const candidates = (state.warehouseBuildings || [])
    .filter((wb) => wb.kind === 'warehouse')
    .filter((wb) => baseRepoKey(String(wb.repo || '')) === repoKey);
  if (!candidates.length) return null;
  const nearest = candidates.reduce((best, wb) => {
    const c = centerPointFor('warehouse', Number(wb.x || 0), Number(wb.y || 0));
    const d = Math.hypot(c.x - featureCenter.x, c.y - featureCenter.y);
    if (!best || d < best.dist) return { wb, dist: d };
    return best;
  }, null);
  if (!nearest || nearest.dist > 240) return null;
  return nearest.wb || null;
}

function refillFeatureFromWarehouse(feature){
  if (!feature) return { ok: false, reason: 'missing feature' };
  const warehouse = nearestWarehouseForFeature(feature);
  if (!warehouse) return { ok: false, reason: 'no connected warehouse' };
  const repoKey = baseRepoKey(String(warehouse.repo || feature.repo || ''));
  const plan = consumeMostImportantWarehouseItem(repoKey);
  if (!plan) return { ok: false, reason: 'warehouse empty' };
  const idx = state.featureBuildings.findIndex((fb) => String(fb.id) === String(feature.id));
  if (idx < 0) return { ok: false, reason: 'feature not found' };
  const prior = state.featureBuildings[idx];
  state.featureBuildings[idx] = {
    ...prior,
    prompt: String(plan.prompt || ''),
    committed: false,
    runId: null,
    phase: 'draft',
    empty: false,
    worktreePath: String(prior.worktreePath || getWorktreeDefault(prior.repo || 'repo', prior.id || 'feature'))
  };
  queuePersist();
  return { ok: true, plan };
}

function renderBelt(pathLayer, belt){
  if (!pathLayer || !belt?.id || !belt?.from || !belt?.to) return false;
  if (state.hiddenBelts?.[belt.id]) return false;
  const dx = Number(belt.to.x || 0) - Number(belt.from.x || 0);
  const dy = Number(belt.to.y || 0) - Number(belt.from.y || 0);
  const dist = Math.hypot(dx, dy);
  if (dist < 1) return false;
  const angle = Math.atan2(dy, dx) * (180 / Math.PI);
  const start = worldToScreen(Number(belt.from.x || 0), Number(belt.from.y || 0));
  const line = document.createElement('div');
  const selected = state.selected?.type === 'belt' && String(state.selected?.data?.id || '') === String(belt.id);
  line.className = `rts-path ${belt.active ? 'active' : ''} ${selected ? 'is-selected' : ''}`;
  line.dataset.beltId = String(belt.id);
  line.style.left = `${start.x}px`;
  line.style.top = `${start.y}px`;
  line.style.width = `${dist}px`;
  line.style.transform = `rotate(${angle}deg)`;
  line.title = String(belt.label || belt.id);
  line.addEventListener('click', (e) => {
    e.stopPropagation();
    state.selected = { type: 'belt', data: { ...belt } };
    renderSelection();
    refreshSelectionVisuals();
  });
  pathLayer.appendChild(line);
  return true;
}

function renderWorld(){
  const world = document.getElementById('world');
  const pathLayer = document.getElementById('pathLayer');
  const activeEntityKeys = new Set();
  const activeUnitKeys = new Set();
  const activeSubunitKeys = new Set();
  world.querySelectorAll('.build-note').forEach((n) => n.remove());
  if (pathLayer) pathLayer.innerHTML = '';
  const selectedBaseId = state.selected?.type === 'base' ? String(state.selected?.data?.id || '') : '';
  const selectedBaseDraftId = state.selected?.type === 'baseDraft' ? String(state.selected?.data?.id || '') : '';
  const selectedBuildingId = state.selected?.type === 'building' ? String(state.selected?.data?.id || '') : '';
  const selectedUnitKey = (state.selected?.type === 'unit' || state.selected?.type === 'subunit')
    ? `${String(state.selected?.data?.runId || '')}:${String(state.selected?.data?.full || '')}`
    : '';

  const runTargets = runTargetCenterMap();
  const activeMap = activeRunAgentMap();
  if (pathLayer) {
    const beltIds = new Set();
    (state.bases || []).forEach((base) => {
      (base.runs || []).forEach((run) => {
        const target = runTargets.get(run.id);
        if (!target) return;
        const from = centerPointFor('base', base.x, base.y);
        const belt = {
          id: `belt:base:${String(base.id)}->run:${String(run.id)}`,
          label: `Base ${String(base.id)} -> Run ${String(run.id).slice(0, 8)}`,
          from: { x: from.x, y: from.y },
          to: { x: Number(target.x || 0), y: Number(target.y || 0) },
          active: !!activeMap.get(run.id)
        };
        if (renderBelt(pathLayer, belt)) beltIds.add(belt.id);
      });
    });
    (state.buildings || []).filter((b) => isResearchKind(b.kind)).forEach((research) => {
      const target = centerPointFor('research', Number(research.x || 0), Number(research.y || 0));
      const nearest = (state.bases || []).reduce((best, base) => {
        const from = centerPointFor('base', Number(base.x || 0), Number(base.y || 0));
        const d = Math.hypot(from.x - target.x, from.y - target.y);
        if (!best || d < best.dist) return { base, from, dist: d };
        return best;
      }, null);
      if (!nearest || nearest.dist < 1) return;
      const belt = {
        id: `belt:base:${String(nearest.base?.id || 'base')}->research:${String(research.id || 'research')}`,
        label: `Base ${String(nearest.base?.id || '')} -> Research ${String(research.id || '')}`,
        from: { x: Number(nearest.from?.x || 0), y: Number(nearest.from?.y || 0) },
        to: { x: Number(target.x || 0), y: Number(target.y || 0) },
        active: true
      };
      if (renderBelt(pathLayer, belt)) beltIds.add(belt.id);
    });
    (state.buildings || []).filter((b) => b.kind === 'warehouse').forEach((warehouse) => {
      const warehouseCenter = centerPointFor('warehouse', Number(warehouse.x || 0), Number(warehouse.y || 0));
      const repoKey = baseRepoKey(String(warehouse.repo || ''));
      const nearestResearch = (state.buildings || [])
        .filter((b) => isResearchKind(b.kind) && baseRepoKey(String(b.repo || '')) === repoKey)
        .reduce((best, research) => {
          const from = centerPointFor('research', Number(research.x || 0), Number(research.y || 0));
          const d = Math.hypot(from.x - warehouseCenter.x, from.y - warehouseCenter.y);
          if (!best || d < best.dist) return { research, from, dist: d };
          return best;
        }, null);
      if (nearestResearch && nearestResearch.dist >= 1) {
        const belt = {
          id: `belt:research:${String(nearestResearch.research?.id || 'research')}->warehouse:${String(warehouse.id || 'warehouse')}`,
          label: `Research ${String(nearestResearch.research?.id || '')} -> Warehouse ${String(warehouse.id || '')}`,
          from: { x: Number(nearestResearch.from?.x || 0), y: Number(nearestResearch.from?.y || 0) },
          to: { x: Number(warehouseCenter.x || 0), y: Number(warehouseCenter.y || 0) },
          active: true
        };
        if (renderBelt(pathLayer, belt)) beltIds.add(belt.id);
      }
      const featureTargets = (state.buildings || [])
        .filter((b) => b.kind === 'feature' && baseRepoKey(String(b.repo || '')) === repoKey)
        .filter((feature) => {
          const fc = centerPointFor('feature', Number(feature.x || 0), Number(feature.y || 0));
          const d = Math.hypot(fc.x - warehouseCenter.x, fc.y - warehouseCenter.y);
          return d <= 240;
        })
        .filter((feature) => {
          const nearest = nearestWarehouseForFeature(feature);
          return !nearest || String(nearest.id || '') === String(warehouse.id || '');
        });
      featureTargets.forEach((feature) => {
        const to = centerPointFor('feature', Number(feature.x || 0), Number(feature.y || 0));
        const belt = {
          id: `belt:warehouse:${String(warehouse.id || 'warehouse')}->feature:${String(feature.id || 'feature')}`,
          label: `Warehouse ${String(warehouse.id || '')} -> Feature ${String(feature.id || '')}`,
          from: { x: Number(warehouseCenter.x || 0), y: Number(warehouseCenter.y || 0) },
          to: { x: Number(to.x || 0), y: Number(to.y || 0) },
          active: false
        };
        if (renderBelt(pathLayer, belt)) beltIds.add(belt.id);
      });
    });
    (state.buildings || []).filter((b) => b.kind === 'library').forEach((library) => {
      const libraryCenter = centerPointFor('library', Number(library.x || 0), Number(library.y || 0));
      const repoKey = baseRepoKey(String(library.repo || ''));
      const nearestUniversity = (state.buildings || [])
        .filter((b) => b.kind === 'university' && baseRepoKey(String(b.repo || '')) === repoKey)
        .reduce((best, university) => {
          const from = centerPointFor('university', Number(university.x || 0), Number(university.y || 0));
          const d = Math.hypot(from.x - libraryCenter.x, from.y - libraryCenter.y);
          if (!best || d < best.dist) return { university, from, dist: d };
          return best;
        }, null);
      if (!nearestUniversity || nearestUniversity.dist < 1) return;
      const belt = {
        id: `belt:university:${String(nearestUniversity.university?.id || 'university')}->library:${String(library.id || 'library')}`,
        label: `University ${String(nearestUniversity.university?.id || '')} -> Library ${String(library.id || '')}`,
        from: { x: Number(nearestUniversity.from?.x || 0), y: Number(nearestUniversity.from?.y || 0) },
        to: { x: Number(libraryCenter.x || 0), y: Number(libraryCenter.y || 0) },
        active: true
      };
      if (renderBelt(pathLayer, belt)) beltIds.add(belt.id);
    });
    if (state.selected?.type === 'belt') {
      const selectedBeltId = String(state.selected?.data?.id || '');
      if (selectedBeltId && !beltIds.has(selectedBeltId)) state.selected = null;
    }
  }

  state.bases.forEach(base => {
    const movable = true;
    const basePort = Number(base.port) || getPortForPath(base.repo || '') || 3333;
    const baseLabel = base.portLabel || pathLabel(base.repo || '');
    const entityKey = `base:${String(base.id)}`;
    activeEntityKeys.add(entityKey);
    const el = upsertIsoEntity({
      className:`base ${movable ? 'movable' : ''} ${selectedBaseId === String(base.id) ? 'is-selected' : ''}`,
      kind:'base',
      entityKey,
      x:base.x,
      y:base.y,
      innerHtml: `${structureMarkup('base')}<div class="port-chip">${esc(baseLabel)} :${basePort}</div>`,
      onClick:() => { state.selected = { type:'base', data:base }; renderSelection(); refreshSelectionVisuals(); }
    });
    el.onmouseenter = (e) => showBuildingHoverCard({ kind:'base', progress:0, run:null }, e.clientX, e.clientY);
    el.onmousemove = (e) => showBuildingHoverCard({ kind:'base', progress:0, run:null }, e.clientX, e.clientY);
    el.onmouseleave = hideBuildingHoverCard;
    if (movable) {
      el.onmousedown = (e) => {
        if (e.button !== 0) return;
        if (state.placementMode) return;
        e.stopPropagation();
        const point = screenToWorld(e.clientX, e.clientY);
        state.draggingEntity = {
          type: 'base',
          id: base.id,
          repoPath: base.repo || '',
          offsetX: point.x - base.x,
          offsetY: point.y - base.y
        };
        state.draggingMoved = false;
      };
    } else {
      el.onmousedown = null;
    }
  });

  (state.baseDrafts || []).forEach((draft) => {
    const entityKey = `baseDraft:${String(draft.id)}`;
    activeEntityKeys.add(entityKey);
    const el = upsertIsoEntity({
      className:`base draft-ghost movable ${selectedBaseDraftId === String(draft.id) ? 'is-selected' : ''}`,
      kind:'base',
      entityKey,
      x:draft.x,
      y:draft.y,
      innerHtml: structureMarkup('base'),
      onClick:() => {
        state.selected = { type:'baseDraft', data:draft };
        renderSelection();
        renderBaseCloneForm(draft);
        refreshSelectionVisuals();
      }
    });
    el.onmousedown = (e) => {
      if (e.button !== 0) return;
      if (state.placementMode) return;
      e.stopPropagation();
      const point = screenToWorld(e.clientX, e.clientY);
      state.draggingEntity = {
        type: 'baseDraft',
        id: draft.id,
        offsetX: point.x - draft.x,
        offsetY: point.y - draft.y
      };
      state.draggingMoved = false;
    };
  });

  state.buildings.forEach(b => {
    const storageIsLibrary = isLibraryLike(b);
    const renderKind = storageIsLibrary ? 'library' : b.kind;
    const timeoutStep = timedOutStepForRun(b.run);
    const status = (b.kind === 'research' || b.kind === 'university')
      ? 'idle'
      : ((b.kind === 'warehouse' || b.kind === 'library' || b.kind === 'power')
        ? 'stored'
        : (timeoutStep ? 'bad' : prettyStatus(getDisplayRunStatus(b.run, b.phase, b.runId || b.id || 'waiting'))));
    const warehouseRepo = baseRepoKey(String(b.repo || ''));
    const warehouseCount = (b.kind === 'warehouse' || b.kind === 'library')
      ? (Array.isArray(b.items) ? b.items.length : 0)
      : 0;
    const cronCount = Array.isArray(state.diag?.cron?.jobs) ? state.diag.cron.jobs.length : Number(state.diag?.cron?.matchingCount || 0);
    const color = (status === 'done')
      ? 'var(--ok)'
      : ((status === 'failed' || status === 'bad') ? 'var(--bad)' : 'var(--warn)');
    const movable = true;
    const featureVisualClass = b.kind === 'feature' ? featureStructureClassName(b) : '';
    const className = ['building', featureVisualClass, movable ? 'movable' : '', selectedBuildingId === String(b.id) ? 'is-selected' : ''].filter(Boolean).join(' ');
    const buildPort = Number(b.port) || getPortForPath(b.worktreePath || b.repo || '') || 3334;
    const buildLabel = b.portLabel || pathLabel(b.worktreePath || b.repo || '');
    const entityKey = `building:${String(b.id)}`;
    activeEntityKeys.add(entityKey);
    const el = upsertIsoEntity({
      className,
      kind: renderKind === 'feature'
        ? 'feature'
        : (renderKind === 'university' ? 'university' : (renderKind === 'research' ? 'research' : (renderKind === 'library' ? 'library' : (renderKind === 'power' ? 'power' : (renderKind === 'warehouse' ? 'warehouse' : 'run'))))),
      entityKey,
      x:b.x,
      y:b.y,
      innerHtml:`
        ${structureMarkup(renderKind === 'feature'
          ? 'feature'
          : (renderKind === 'university' ? 'university' : (renderKind === 'research' ? 'research' : (renderKind === 'library' ? 'library' : (renderKind === 'power' ? 'power' : (renderKind === 'warehouse' ? 'warehouse' : 'run'))))), b.variant)}
        <div class="port-chip">${esc(buildLabel)} :${buildPort}</div>
        ${(b.kind === 'research' || b.kind === 'university')
          ? '<div class="notice" style="position:absolute;left:12px;right:12px;bottom:8px">Research queue ready</div>'
          : (b.kind === 'power')
            ? `<div class="notice" style="position:absolute;left:12px;right:12px;bottom:8px">Cron jobs: ${cronCount}</div>`
          : (b.kind === 'warehouse' || b.kind === 'library')
            ? `<div class="notice" style="position:absolute;left:12px;right:12px;bottom:8px">${storageIsLibrary ? 'Archived entries' : 'Stored items'}: ${warehouseCount}</div>`
          : `<div class="progress" style="position:absolute;left:12px;right:12px;bottom:8px"><div class="bar" style="width:${b.progress || 0}%;background:${color}"></div></div>`}
      `,
      onClick:() => {
        state.selected = { type:'building', data:b };
        renderSelection();
        if (b.kind === 'feature') renderRunSetupPanel(b.id);
        if (b.kind === 'research') renderResearchLabPanel(b.id);
        if (b.kind === 'university') renderUniversityPanel(b.id);
        if (isStorageKind(b.kind)) renderStoragePanelForBuilding(b.id);
        refreshSelectionVisuals();
      }
    });
    el.onmouseenter = (e) => showBuildingHoverCard(b, e.clientX, e.clientY);
    el.onmousemove = (e) => showBuildingHoverCard(b, e.clientX, e.clientY);
    el.onmouseleave = hideBuildingHoverCard;
    if (movable) {
      el.onmousedown = (e) => {
        if (e.button !== 0) return;
        if (state.placementMode) return;
        e.stopPropagation();
        const point = screenToWorld(e.clientX, e.clientY);
        state.draggingEntity = {
          type: b.kind === 'feature'
            ? 'feature'
            : (b.kind === 'university' ? 'university' : (b.kind === 'research' ? 'research' : (storageIsLibrary ? 'library' : (b.kind === 'power' ? 'power' : (b.kind === 'warehouse' ? 'warehouse' : 'run'))))),
          id: b.id,
          runId: b.runId || b.run?.id || (b.kind === 'run' ? b.id : ''),
          repoPath: b.repo || '',
          worktreePath: b.worktreePath || '',
          offsetX: point.x - b.x,
          offsetY: point.y - b.y
        };
        state.draggingMoved = false;
      };
    } else {
      el.onmousedown = null;
    }
  });

  state.units.forEach(u => {
    const liveEntry = getLiveAgentEntry(u.runId, u.full);
    const unitKey = `${String(u.runId || '')}:${String(u.full || '')}`;
    activeUnitKeys.add(unitKey);
    let el = world.querySelector(`.unit[data-unit-key="${CSS.escape(unitKey)}"]`);
    if (!el) {
      el = document.createElement('div');
      world.appendChild(el);
    }
    const selectedUnit = selectedUnitKey === unitKey;
    el.className = `unit ${liveEntry ? (liveEntry.stale ? 'live-stale' : 'live-running') : ''} ${selectedUnit ? 'is-selected' : ''}`;
    if (u.moving) el.classList.add('moving');
    const p = worldToScreen(u.x, u.y);
    el.style.left = `${p.x}px`;
    el.style.top = `${p.y}px`;
    el.style.zIndex = String(worldDepth(u.y, 2000));
    el.title = `${u.label} • model: ${u.model || 'unknown'}${liveEntry ? ` • ${liveEntry.stale ? 'stale' : 'running'}` : ''}`;
    el.dataset.runId = u.runId;
    el.dataset.agentId = u.full;
    el.dataset.unitKey = unitKey;
    el.dataset.baseTitle = `${u.label} • model: ${u.model || 'unknown'}`;
    el.onclick = () => { state.selected = { type:'unit', data:u }; renderSelection(); refreshSelectionVisuals(); };

    for (let i = 0; i < u.subagents; i++) {
      const angle = (Date.now()/620 + i * (Math.PI*2 / u.subagents));
      const sx = u.x + 8 + Math.cos(angle) * 22;
      const sy = u.y + 8 + Math.sin(angle) * 16;
      const sp = worldToScreen(sx, sy);
      const subKey = `${unitKey}:${i}`;
      activeSubunitKeys.add(subKey);
      let sub = world.querySelector(`.subunit[data-subunit-key="${CSS.escape(subKey)}"]`);
      if (!sub) {
        sub = document.createElement('div');
        world.appendChild(sub);
      }
      sub.className = `subunit ${selectedUnit ? 'is-selected' : ''}`;
      sub.style.left = `${sp.x}px`;
      sub.style.top = `${sp.y}px`;
      sub.style.zIndex = String(worldDepth(sy, 1900));
      sub.title = `subagent • ${u.faction}`;
      sub.dataset.unitKey = unitKey;
      sub.dataset.subunitKey = subKey;
      sub.onclick = () => { state.selected = { type:'subunit', data:u }; renderSelection(); refreshSelectionVisuals(); };
    }
  });

  world.querySelectorAll('.entity[data-entity-key]').forEach((node) => {
    const key = node.getAttribute('data-entity-key') || '';
    if (!activeEntityKeys.has(key)) node.remove();
  });
  world.querySelectorAll('.unit[data-unit-key]').forEach((node) => {
    const key = node.getAttribute('data-unit-key') || '';
    if (!activeUnitKeys.has(key)) node.remove();
  });
  world.querySelectorAll('.subunit[data-subunit-key]').forEach((node) => {
    const key = node.getAttribute('data-subunit-key') || '';
    if (!activeSubunitKeys.has(key)) node.remove();
  });

  state.buildings.forEach((b) => {
    const status = String(b.run?.status || '').toLowerCase();
    const timeoutStep = timedOutStepForRun(b.run);
    const pos = worldToScreen(Number(b.x || 0) + 26, Number(b.y || 0) - 42);
    if (timeoutStep) {
      const note = document.createElement('div');
      note.className = 'build-note bad';
      note.style.left = `${pos.x}px`;
      note.style.top = `${pos.y}px`;
      note.innerHTML = `<span class="bad-tag">BAD</span><br>Timeout on ${esc(prettyStepName(timeoutStep.step_id || 'step'))}<br>Retry ${Number(timeoutStep.retry_count || 0)}`;
      world.appendChild(note);
      return;
    }
    if (status === 'completed' || status === 'done') {
      if (!b.prUrl) return;
      const note = document.createElement('div');
      note.className = 'build-note';
      note.style.left = `${pos.x}px`;
      note.style.top = `${pos.y}px`;
      note.innerHTML = `PR READY<br><a href="${esc(b.prUrl)}" target="_blank" rel="noopener">Open pull request</a>`;
      world.appendChild(note);
    }
  });
}

function renderUnitsLiveState(){
  const nodes = document.querySelectorAll('.unit[data-run-id][data-agent-id]');
  nodes.forEach((node) => {
    const runId = node.getAttribute('data-run-id') || '';
    const agentId = node.getAttribute('data-agent-id') || '';
    const baseTitle = node.getAttribute('data-base-title') || '';
    const liveEntry = getLiveAgentEntry(runId, agentId);
    node.classList.remove('live-running', 'live-stale');
    if (liveEntry) node.classList.add(liveEntry.stale ? 'live-stale' : 'live-running');
    node.title = `${baseTitle}${liveEntry ? ` • ${liveEntry.stale ? 'stale' : 'running'}` : ''}`;
  });
}

function renderSkillTree(type, heading){
  return '';
}

function renderRunAgentsConsole(run, selectedAgentId){
  const panel = document.getElementById('actionPanel');
  panel.dataset.mode = 'agents';
  panel.dataset.featureId = '';
  setFeatureMode(false);
  if (!run) {
    panel.innerHTML = `${panelToolbar('Agent Console')}<div class="notice">No run selected.</div>`;
    wirePanelDeleteButton();
    stopAgentStream();
    return;
  }
  const agents = deriveRunAgents(run);
  panel.innerHTML = `
    ${panelToolbar('Agent Console', `Run ${String(run.id || '').slice(0, 12)}`)}
    <div class="kv"><strong>Run:</strong> ${esc(run.id.slice(0, 12))}</div>
    <div class="kv"><strong>Task:</strong> ${esc(run.task || '')}</div>
    <div class="notice" id="restartNotice">Select an agent row; restart forces requeue and kick. Press R on Developer to redo from failed test feedback.</div>
    ${renderAgentStatusList(agents, run)}
    <div class="notice" style="margin-top:8px">Read-only terminal stream. No command input available.</div>
  `;
  wirePanelDeleteButton();
  const rows = panel.querySelectorAll('#assignedAgentList .agent-row');
  rows.forEach(row => {
    row.addEventListener('click', () => {
      const runId = row.getAttribute('data-run');
      const agentId = row.getAttribute('data-agent');
      const stepId = row.getAttribute('data-step') || '';
      if (!runId || !agentId) return;
      state.streamSelectionByRun[runId] = streamSelectionKey(agentId, stepId);
      startAgentStream(runId, agentId, stepId);
      panel.querySelectorAll('#assignedAgentList .agent-row').forEach(r => r.classList.remove('active'));
      row.classList.add('active');
    });
  });
  const restartBtns = panel.querySelectorAll('#assignedAgentList .agent-restart');
  restartBtns.forEach((btn) => {
    btn.addEventListener('click', async (e) => {
      e.stopPropagation();
      const runId = btn.getAttribute('data-restart-run');
      const agentId = btn.getAttribute('data-restart-agent');
      if (!runId || !agentId) return;
      const restartNotice = panel.querySelector('#restartNotice');
      try {
        btn.disabled = true;
        if (restartNotice) restartNotice.textContent = `Restart requested for ${agentId}...`;
        const rr = await postJson('/api/rts/agent/restart', { runId, agentId });
        state.runs = await json('/api/runs');
        rebuildScene();
        const refreshed = (state.runs || []).find(r => r.id === runId);
        if (refreshed) {
          renderRunAgentsConsole(refreshed, agentId);
          const refreshedNotice = document.querySelector('#actionPanel #restartNotice');
          if (refreshedNotice) refreshedNotice.textContent = rr?.kicked
            ? `Restart accepted for ${agentId}. Step reset and kick sent.`
            : `Restart accepted for ${agentId}. Step reset; waiting for cron fallback.`;
        }
      } catch (err) {
        const message = String(err?.message || err || 'unknown_error');
        const human = message.includes('agent_waiting_not_restartable')
          ? 'Restart rejected: this agent is waiting. Restart a running/failed/done agent instead.'
          : `Restart failed: ${message}`;
        const freshNotice = document.querySelector('#actionPanel #restartNotice');
        if (freshNotice) freshNotice.textContent = human;
        else if (restartNotice) restartNotice.textContent = human;
      } finally {
        btn.disabled = false;
      }
    });
  });
  const redoBtns = panel.querySelectorAll('#assignedAgentList .agent-redo');
  redoBtns.forEach((btn) => {
    btn.addEventListener('click', async (e) => {
      e.stopPropagation();
      const runId = btn.getAttribute('data-redo-run');
      const restartNotice = panel.querySelector('#restartNotice');
      if (!runId) return;
      try {
        btn.disabled = true;
        if (restartNotice) restartNotice.textContent = 'Redoing Developer from failed test feedback...';
        const rr = await postJson('/api/rts/agent/redo-developer', { runId });
        markRunRelaunched(runId);
        rebuildScene();
        state.runs = await json('/api/runs');
        rebuildScene();
        const refreshed = (state.runs || []).find(r => r.id === runId);
        if (refreshed) renderRunAgentsConsole(refreshed, 'feature-dev/developer');
        if (restartNotice) restartNotice.textContent = rr?.kicked
          ? `Developer redo queued (story ${rr?.storyId || 'rerun'}), kicked immediately.`
          : `Developer redo queued (story ${rr?.storyId || 'rerun'}); waiting for cron fallback.`;
      } catch (err) {
        if (restartNotice) restartNotice.textContent = `Redo failed: ${err.message || err}`;
      } finally {
        btn.disabled = false;
      }
    });
  });
  renderTerminalViewer();
  const selectedStepId = String(state.stream.runId === run.id ? (state.stream.stepId || '') : '');
  const preferredSelectionRaw = selectedAgentId || state.streamSelectionByRun[run.id] || (state.stream.runId === run.id ? streamSelectionKey(state.stream.agentId, selectedStepId) : '');
  const preferredSelection = parseStreamSelectionKey(preferredSelectionRaw);
  if (preferredSelection.agentId) {
    const selector = preferredSelection.stepId
      ? `#assignedAgentList .agent-row[data-agent="${CSS.escape(preferredSelection.agentId)}"][data-step="${CSS.escape(preferredSelection.stepId)}"]`
      : `#assignedAgentList .agent-row[data-agent="${CSS.escape(preferredSelection.agentId)}"]`;
    const row = panel.querySelector(selector);
    if (row && !(state.stream.runId === run.id && state.stream.agentId === preferredSelection.agentId && String(state.stream.stepId || '') === String(preferredSelection.stepId || ''))) row.click();
  }
}

function renderSelection(){
  queuePersist();
  const panel = document.getElementById('actionPanel');
  if (!panel) return;
  const s = state.selected;
  if (!s) {
    closeLibraryModal();
    renderDefaultActionPanel();
    return;
  }
  const keepLibraryModal = s.type === 'building' && isLibraryBuilding(s.data);
  if (!keepLibraryModal) closeLibraryModal();

  if (s.type === 'base') {
    setFeatureMode(false);
    const b = s.data;
    const basePort = Number(b.port) || getPortForPath(b.repo || '') || 3333;
    const baseLabel = b.portLabel || pathLabel(b.repo || '');
    const stages = baseStageKanban(b.id);
    const totalWaiting = stages.reduce((sum, stage) => sum + Number(stage.waiting || 0), 0);
    const totalDone = stages.reduce((sum, stage) => sum + Number(stage.done || 0), 0);
    panel.dataset.mode = 'base';
    panel.dataset.featureId = '';
    panel.innerHTML = `
      ${panelToolbar('Base Kanban', 'Pipeline stage queue counts')}
      <div class="kv"><strong>Repo:</strong> ${esc(b.repo || 'unlinked')}</div>
      <div class="kv"><strong>Role:</strong> ${esc(baseLabel)}</div>
      <div class="kv"><strong>Runtime:</strong> ${runtimeLink(basePort)}</div>
      <div class="kv"><strong>Factories:</strong> ${(state.featureBuildings || []).filter((fb) => String(fb?.baseId || '') === String(b.id || '')).length}</div>
      <div class="kv"><strong>Waiting:</strong> ${totalWaiting}</div>
      <div class="kv"><strong>Done:</strong> ${totalDone}</div>
      <div class="build-card" style="margin-top:8px">
        <div class="kv"><strong>Stages</strong></div>
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(110px,1fr));gap:8px;margin-top:8px">
          ${stages.length ? stages.map((stage) => `
            <div style="border:1px solid #3f6283;border-radius:8px;padding:8px;background:#0a1f34">
              <div style="font-weight:600;font-size:11px;margin-bottom:6px">${esc(stage.label)}</div>
              <div class="kv"><strong>Waiting:</strong> ${Number(stage.waiting || 0)}</div>
              <div class="kv"><strong>Done:</strong> ${Number(stage.done || 0)}</div>
            </div>
          `).join('') : `
            <div class="notice">No stage data yet for this base.</div>
          `}
        </div>
      </div>
      <div class="notice">Counts are scoped to runs attached to this base and grouped by workflow stage.</div>
    `;
    wirePanelDeleteButton();
    stopAgentStream();
    return;
  }

  if (s.type === 'belt') {
    setFeatureMode(false);
    const b = s.data || {};
    panel.dataset.mode = 'belt';
    panel.dataset.featureId = '';
    panel.innerHTML = `
      ${panelToolbar('Conveyor Belt', 'Directional logistics link')}
      <div class="kv"><strong>ID:</strong> ${esc(String(b.id || '-'))}</div>
      <div class="kv"><strong>Flow:</strong> ${esc(String(b.label || '-'))}</div>
      <div class="notice">Delete removes this belt segment from the map and persists that choice.</div>
    `;
    wirePanelDeleteButton();
    return;
  }
  if (s.type === 'building') {
    const b = s.data;
    if (b.kind === 'feature') {
      setFeatureMode(true);
      const actionPanel = document.getElementById('actionPanel');
      const shownFeatureId = String(actionPanel?.dataset?.featureId || '');
      const isSameFeaturePanel = actionPanel?.dataset?.mode === 'feature' && shownFeatureId === String(b.id || '');
      if (!isEditingActionPanel() || !isSameFeaturePanel) renderRunSetupPanel(b.id);
      return;
    }
    if (b.kind === 'research') {
      setFeatureMode(false);
      if (!isEditingActionPanel()) renderResearchLabPanel(b.id);
      return;
    }
    if (b.kind === 'university') {
      setFeatureMode(false);
      if (!isEditingActionPanel()) renderUniversityPanel(b.id);
      return;
    }
    if (isStorageKind(b.kind)) {
      setFeatureMode(false);
      if (!isEditingActionPanel()) renderStoragePanelForBuilding(b.id);
      return;
    }
    renderRunAgentsConsole(b.run);
    return;
  }
  if (s.type === 'unit') {
    setFeatureMode(false);
    const run = (state.runs || []).find((r) => r.id === s.data.runId);
    renderRunAgentsConsole(run, s.data.full);
    return;
  }
  if (s.type === 'subunit') {
    setFeatureMode(false);
    const u = s.data;
    panel.innerHTML = `${panelToolbar('Subagent', 'Read-only')}<div class="kv"><strong>Parent unit:</strong> ${esc(u.label)}</div><div class="kv"><strong>Faction:</strong> ${esc(u.faction)}</div>`;
    wirePanelDeleteButton();
    stopAgentStream();
    return;
  }
  if (s.type === 'baseDraft') {
    setFeatureMode(false);
    renderBaseCloneForm(s.data);
    return;
  }
}

function renderBaseCloneForm(draft){
  setFeatureMode(false);
  const panel = document.getElementById('actionPanel');
  const repoOptions = (state.localRepos || []).map(r => {
    const suggested = Number(r.suggestedPort) || getPortForPath(r.path) || '';
    const suffix = suggested ? ` • :${suggested}` : '';
    return `<option value="${esc(r.path)}">${esc(r.name)} • ${esc(r.path)}${suffix}</option>`;
  }).join('');
  panel.innerHTML = `
    ${panelToolbar('Base Setup', 'Configure repository')}
    <div class="kv"><strong>Placement:</strong> x ${Math.round(draft.x)}, y ${Math.round(draft.y)}</div>
    <label class="kv">Use existing local repo
      <select id="existingRepoSelect">
        <option value="">— none / create via clone —</option>
        ${repoOptions}
      </select>
    </label>
    <label class="kv">Repository URL (for clone)
      <input id="cloneRepoUrl" placeholder="https://github.com/org/repo.git" value="${esc(draft.repoUrl || '')}" />
    </label>
    <label class="kv">Target path
      <input id="cloneTargetPath" placeholder="../repo-worktree" value="${esc(draft.targetPath || '')}" />
    </label>
    <label class="kv">Base port
      <input id="basePortInput" type="number" min="1" max="65535" value="${esc(String(draft.port || 3333))}" />
    </label>
    <button id="saveBaseCloneBtn">Create Base</button>
    <div class="notice" style="margin-top:7px" id="baseMutationNotice">Select an existing repo OR provide clone URL + target path.</div>
  `;
  wirePanelDeleteButton();

  const existingRepoSelect = document.getElementById('existingRepoSelect');
  existingRepoSelect.addEventListener('change', (e) => {
    draft.existingRepoPath = e.target.value || '';
    if (draft.existingRepoPath) {
      draft.targetPath = draft.existingRepoPath;
      const repoMeta = (state.localRepos || []).find((r) => r.path === draft.existingRepoPath);
      draft.port = Number(repoMeta?.suggestedPort) || getPortForPath(draft.existingRepoPath) || draft.port || 3333;
      const pathInput = document.getElementById('cloneTargetPath');
      if (pathInput) pathInput.value = draft.targetPath;
      const portInput = document.getElementById('basePortInput');
      if (portInput) portInput.value = String(draft.port);
    }
    queuePersist();
  });
  document.getElementById('cloneRepoUrl').addEventListener('input', e => { draft.repoUrl = e.target.value; queuePersist(); });
  document.getElementById('cloneTargetPath').addEventListener('input', e => { draft.targetPath = e.target.value; queuePersist(); });
  document.getElementById('basePortInput').addEventListener('input', e => {
    draft.port = Number(e.target.value) || draft.port || 3333;
    queuePersist();
  });

  const submitBaseDraft = async () => {
    const usingExisting = !!draft.existingRepoPath;
    const notice = document.getElementById('baseMutationNotice');
    try {
      if (!usingExisting && (!draft.repoUrl || !draft.targetPath)) throw new Error('Choose an existing repo, or provide repo URL and target path.');
      if (usingExisting && !draft.targetPath) throw new Error('Existing repo path is required.');

      notice.textContent = 'Creating base...';
      const payload = usingExisting
        ? { useExistingRepoPath: draft.existingRepoPath }
        : { repoUrl: draft.repoUrl, targetPath: draft.targetPath };
      const result = await postJson('/api/rts/base/clone', { ...payload, placement: { x: draft.x, y: draft.y } });
      const base = {
        id:`custom-base-${Date.now()}`,
        x:draft.x,
        y:draft.y,
        repo:result.repoPath,
        worktreePath: result.repoPath,
        port: Number(draft.port) || getPortForPath(result.repoPath) || 3333,
        portLabel: pathLabel(result.repoPath),
        workerPool: normalizeBaseWorkerPool({}),
        source:'custom',
        cloneMeta: {
          mode: result.mode,
          repoUrl: draft.repoUrl || '',
          targetPath: draft.targetPath || result.repoPath,
          existingRepoPath: draft.existingRepoPath || ''
        },
        runs:[]
      };
      await postJson('/api/rts/layout/position', {
        entityType: 'base',
        entityId: base.id,
        runId: null,
        repoPath: base.repo || null,
        worktreePath: base.worktreePath || null,
        x: base.x,
        y: base.y,
        allowCreate: true,
        payload: {
          workerPool: base.workerPool
        }
      });
      setPortForPath(base.repo, base.port);
      removeBaseDraftById(draft.id);
      state.customBases.push(base);
      state.selected = { type:'base', data:base };
      queuePersist();
      panel.innerHTML = `${panelToolbar('Base Setup')}<div class="kv"><strong>Base created.</strong></div><div class="kv"><strong>Repo:</strong> ${esc(base.repo)}</div><div class="kv"><strong>Mode:</strong> ${esc(result.mode)}</div><div class="notice">Ready for feature worktree and run setup.</div>`;
      wirePanelDeleteButton();
      rebuildScene();
      renderSelection();
    } catch (err) {
      notice.textContent = `Error: ${err.message || err}`;
    }
  };
  document.getElementById('saveBaseCloneBtn').onclick = submitBaseDraft;
  ['cloneRepoUrl', 'cloneTargetPath'].forEach((id) => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('keydown', (e) => {
      if (e.key !== 'Enter') return;
      e.preventDefault();
      submitBaseDraft();
    });
  });
}

function statusTone(status){
  if (status === 'done') return 'var(--ok)';
  if (status === 'running') return 'var(--warn)';
  if (status === 'stale') return '#ff8faa';
  if (status === 'failed') return 'var(--bad)';
  if (status === 'pending') return '#88a9be';
  if (status === 'skipped') return '#9fb5c6';
  return '#6b859e';
}

function prettyStatus(status){
  if (status === 'pending') return 'queued';
  return status || 'idle';
}

function canRestartAgentStatus(status){
  const s = String(status || '').toLowerCase();
  return s !== 'waiting' && s !== 'pending' && s !== 'idle' && s !== 'skipped';
}

function findRelevantRun(draft){
  if (!draft) return null;
  if (draft.runId) return (state.runs || []).find(r => r.id === draft.runId) || null;
  return null;
}

function expectedAgentCountForWorkflow(workflowId){
  const wf = (state.workflows || []).find((w) => String(w?.id || '') === String(workflowId || ''));
  return Array.isArray(wf?.steps) ? wf.steps.length : 0;
}

function deriveRunAgents(run){
  const workflow = (state.workflows || []).find((wf) => String(wf?.id || '') === String(run?.workflow_id || ''));
  if (workflow?.steps?.length) {
    return workflow.steps.map((wfStep, idx) => {
      const wfStepId = String(wfStep.id || '');
      const stepRows = (run?.steps || []).filter((step) => String(step.step_id || '') === wfStepId);
      const agentId = String(stepRows[0]?.agent_id || `${workflow.id}/${wfStep.agent}@run:${run?.id || ''}`);
      const statuses = stepRows.map((s) => String(s.status || 'pending'));
      const live = getLiveAgentEntry(run?.id, agentId, wfStepId);
      let status = 'waiting';
      if (live && !live.stale) status = 'running';
      else if (live && live.stale) status = 'stale';
      else if (statuses.includes('running')) status = 'running';
      else if (statuses.includes('failed')) status = 'failed';
      else if (statuses.length && statuses.every((s) => s === 'done' || s === 'skipped')) status = 'done';
      else if (statuses.includes('pending')) status = 'pending';
      const base = baseAgentId(agentId);
      return {
        slotId: `${wfStep.id}:${idx + 1}`,
        stepId: wfStepId,
        agentId,
        status,
        displayName: `${prettyStepName(String(wfStep.id || 'step'))} • ${base.split('/').pop() || base}`
      };
    });
  }
  const map = new Map();
  (run?.steps || []).forEach((step) => {
    if (!step.agent_id) return;
    if (!map.has(step.agent_id)) map.set(step.agent_id, []);
    map.get(step.agent_id).push(step.status || 'pending');
  });
  return Array.from(map.entries()).map(([agentId, statuses]) => {
    const live = getLiveAgentEntry(run?.id, agentId);
    let status = 'waiting';
    if (live && !live.stale) status = 'running';
    else if (live && live.stale) status = 'stale';
    else if (statuses.includes('running')) status = 'running';
    else if (statuses.includes('failed')) status = 'failed';
    else if (statuses.every((s) => s === 'done' || s === 'skipped')) status = 'done';
    else if (statuses.includes('pending')) status = 'pending';
    return { slotId: agentId, stepId: '', agentId, status, displayName: baseAgentId(agentId) };
  });
}

function prettyStepName(stepId){
  const raw = String(stepId || '').trim().toLowerCase();
  if (!raw) return 'Step';
  if (raw === 'pr') return 'PR creation';
  return raw
    .split(/[_-]+/)
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(' ');
}

function resolveStepLabel(run, stepRef){
  if (!stepRef) return '';
  const row = (run?.steps || []).find((step) => step.id === stepRef || step.step_id === stepRef);
  return String(row?.step_id || stepRef || '');
}

function summarizeSingleLine(text, max = 180){
  return String(text || '').replace(/\s+/g, ' ').trim().slice(0, max);
}

function detectPrBlocker(text){
  const raw = String(text || '').toLowerCase();
  if (!raw) return '';
  if (/gh auth|not logged in|authentication failed/.test(raw)) {
    return 'GitHub auth looks missing. Run `gh auth status` in the worktree and sign in if needed.';
  }
  if (/no commits between|nothing to compare/.test(raw)) {
    return 'GitHub reports no commits between base and head. Commit and push changes before creating a PR.';
  }
  if (/has no upstream branch|set-upstream|must push/.test(raw)) {
    return 'Branch is not pushed with upstream. Push the branch, then retry PR creation.';
  }
  if (/already exists|pull request already/.test(raw)) {
    return 'A PR may already exist for this branch. Check existing PRs before retrying.';
  }
  if (/resource not accessible|forbidden|permission denied/.test(raw)) {
    return 'GitHub token/permissions look insufficient for PR creation.';
  }
  if (/could not resolve host|timed out|network/.test(raw)) {
    return 'Network/GitHub API connectivity issue while creating PR.';
  }
  return '';
}

function buildPrStatusLines(run, events){
  if (String(run?.workflow_id || '') !== 'feature-dev') return [];
  const prStep = (run?.steps || []).find((step) => String(step.step_id || '').toLowerCase() === 'pr');
  if (!prStep) return [];
  const prUrl = extractPrUrl(run);
  if (prUrl) return [`[pr] Pull request detected: ${prUrl}`];

  const status = String(prStep.status || 'waiting');
  const runStatus = String(run?.status || 'running');
  if ((status === 'waiting' || status === 'pending') && runStatus === 'running') return [];

  const lines = [];
  if ((status === 'waiting' || status === 'pending') && (runStatus === 'failed' || runStatus === 'cancelled')) {
    const blockedBy = (run?.steps || [])
      .filter((step) => String(step.step_id || '').toLowerCase() !== 'pr')
      .find((step) => step.status === 'failed');
    const blockerLabel = blockedBy ? prettyStepName(String(blockedBy.step_id || blockedBy.id || 'step')) : 'an earlier step';
    lines.push(`[pr] PR step did not run because ${blockerLabel} failed.`);
    if (blockedBy?.output) {
      lines.push(`[pr] Blocking reason: ${summarizeSingleLine(String(blockedBy.output), 240)}`);
    }
  } else
  if (status === 'failed') lines.push('[pr] PR step failed, so no pull request was created.');
  else if (status === 'done') lines.push('[pr] PR step completed but no pull request URL was found.');
  else if (status === 'running') lines.push('[pr] PR step is running. Waiting for `gh pr create` output.');
  else lines.push(`[pr] PR step status: ${status}.`);

  const lastPrEvent = [...(events || [])].reverse().find((evt) => {
    const stepLabel = resolveStepLabel(run, evt.stepId).toLowerCase();
    return stepLabel === 'pr' || (evt.event === 'run.failed' && runStatus === 'failed');
  });
  const detail = String(lastPrEvent?.detail || prStep.output || '').trim();
  const blocker = detectPrBlocker(detail);
  if (blocker) lines.push(`[pr] ${blocker}`);
  else if (detail) lines.push(`[pr] Last detail: ${summarizeSingleLine(detail, 240)}`);
  return lines;
}

function formatEventLine(evt, stepLabel = ''){
  const t = new Date(evt.ts || Date.now());
  const hhmmss = t.toLocaleTimeString([], { hour:'2-digit', minute:'2-digit', second:'2-digit' });
  return `[${hhmmss}] ${formatActivityDesc(evt, stepLabel)}`;
}

function formatActivityDesc(evt, stepLabel = '') {
  const e = evt.event;
  const story = evt.storyTitle ? `${evt.storyId}: "${evt.storyTitle}"` : (evt.storyId || '');
  const stepName = prettyStepName(stepLabel);
  const hasStep = !!stepLabel;
  switch (e) {
    case 'run.started': return 'Run started';
    case 'run.completed': return 'Run completed';
    case 'run.failed': return `Run failed${evt.detail ? `: ${evt.detail}` : ''}`;
    case 'step.pending': return hasStep ? `${stepName} pending` : 'Step pending';
    case 'step.running': return hasStep ? `${stepName} started` : 'Claimed step';
    case 'step.done': return hasStep ? `${stepName} completed` : 'Step completed';
    case 'step.failed': return hasStep
      ? `${stepName} failed${evt.detail ? `: ${evt.detail}` : ''}`
      : `Step failed${evt.detail ? `: ${evt.detail}` : ''}`;
    case 'step.timeout': return hasStep
      ? `${stepName} timed out${evt.detail ? `: ${evt.detail}` : ''}`
      : `Step timed out${evt.detail ? `: ${evt.detail}` : ''}`;
    case 'story.started': return `Claimed story ${story}`;
    case 'story.done': return `Completed ${story}`;
    case 'story.verified': return `Verified ${story}`;
    case 'story.retry': return `Retry ${story}${evt.detail ? `: ${evt.detail}` : ''}`;
    case 'story.failed': return `Story failed ${story}${evt.detail ? `: ${evt.detail}` : ''}`;
    case 'pipeline.advanced': return hasStep ? `Pipeline advanced to ${stepName}` : 'Pipeline advanced';
    default: return `${e}${evt.detail ? `: ${evt.detail}` : ''}`;
  }
}

async function startAgentStream(runId, agentId, stepId = ''){
  if (state.stream.runId === runId && state.stream.agentId === agentId && String(state.stream.stepId || '') === String(stepId || '')) return;
  stopAgentStream();
  state.stream = { ...state.stream, runId, agentId, stepId: String(stepId || ''), targetLines: [], displayedLines: [], stepStatus:'idle', loading:true };
  renderTerminalViewer();

  const poll = async () => {
    if (!state.stream.runId || !state.stream.agentId) return;
    try {
      const [events, run] = await Promise.all([
        json(`/api/runs/${state.stream.runId}/events`),
        json(`/api/runs/${state.stream.runId}`)
      ]);
      const runActivityLines = (events || []).map((evt) => {
        const t = new Date(evt.ts || Date.now());
        const time = t.toLocaleTimeString([], { hour:'2-digit', minute:'2-digit', second:'2-digit' });
        const stepLabel = resolveStepLabel(run, evt.stepId);
        const agentShort = evt.agentId ? String(evt.agentId).split('/').pop() : '--';
        return `[${time}] ${agentShort} ${formatActivityDesc(evt, stepLabel)}`;
      });
      const streamStepId = String(state.stream.stepId || '');
      const agentSteps = (run.steps || []).filter((step) => {
        if (step.agent_id !== state.stream.agentId) return false;
        if (!streamStepId) return true;
        return String(step.step_id || '') === streamStepId;
      });
      const agentStepIdSet = new Set(agentSteps.map((s) => s.id));
      const agentEvents = (events || [])
        .filter((evt) => {
          if (evt.agentId === state.stream.agentId) return true;
          if (evt.stepId && agentStepIdSet.has(evt.stepId)) return true;
          return false;
        })
        .map((evt) => formatEventLine(evt, resolveStepLabel(run, evt.stepId)));
      const stepOutputs = (run.steps || [])
        .filter(step => step.agent_id === state.stream.agentId && step.output)
        .flatMap(step => String(step.output).split('\n').filter(Boolean).map(line => `[${step.step_id}] ${line}`));
      const failedStep = agentSteps.find((step) => step.status === 'failed');
      const runningStep = agentSteps.find((step) => step.status === 'running');
      const fallback = (!agentEvents.length && !stepOutputs.length && failedStep)
        ? [`[${failedStep.step_id}] STATUS: failed`, failedStep.output ? String(failedStep.output) : 'No output captured for failed step.']
        : [];
      if (failedStep && failedStep.output && !stepOutputs.length) {
        fallback.push(`[${failedStep.step_id}] FAILURE: ${String(failedStep.output).slice(0, 800)}`);
      }
      if (!agentEvents.length && !stepOutputs.length && !failedStep && agentSteps.length) {
        const newest = [...agentSteps].sort((a, b) => Date.parse(String(b.updated_at || 0)) - Date.parse(String(a.updated_at || 0)))[0];
        if (newest) fallback.push(`[${newest.step_id}] ${prettyStatus(newest.status)} • last update ${newest.updated_at || 'unknown'}`);
      }
      if (!agentEvents.length && !stepOutputs.length && !failedStep && runningStep) {
        fallback.push(`[${runningStep.step_id}] Agent is running. Waiting for first output...`);
      }
      if (!agentEvents.length && !stepOutputs.length && runActivityLines.length) {
        fallback.push('[activity] No agent-scoped lines yet; showing latest run activity:');
        fallback.push(...runActivityLines.slice(-12));
      }
      const prStatusLines = buildPrStatusLines(run, events);
      const unique = [...new Set([...agentEvents, ...stepOutputs, ...fallback, ...prStatusLines])];
      state.stream.targetLines = unique;
      state.stream.stepStatus = deriveRunAgents(run).find((a) => {
        if (a.agentId !== state.stream.agentId) return false;
        if (!streamStepId) return true;
        return String(a.stepId || '') === streamStepId;
      })?.status || 'idle';
      state.stream.loading = false;
      renderTerminalViewer();
    } catch {
      state.stream.loading = false;
      renderTerminalViewer();
    }
  };

  await poll();
  state.stream.pollTimer = setInterval(poll, 3000);
  state.stream.revealTimer = setInterval(() => {
    if (!state.stream.runId || !state.stream.agentId) return;
    const nextIndex = state.stream.displayedLines.length;
    if (nextIndex >= state.stream.targetLines.length) return;
    state.stream.displayedLines.push(state.stream.targetLines[nextIndex]);
    renderTerminalViewer();
  }, 90);
}

function stopAgentStream(){
  if (state.stream.pollTimer) clearInterval(state.stream.pollTimer);
  if (state.stream.revealTimer) clearInterval(state.stream.revealTimer);
  state.stream.pollTimer = null;
  state.stream.revealTimer = null;
}

function renderTerminalViewer(){
  const host = document.getElementById('terminalViewerHost');
  if (!host) return;
  if (!state.stream.runId || !state.stream.agentId) {
    host.innerHTML = `<div class="notice" style="margin-top:8px">Click an agent row to view live read-only output stream.</div>`;
    return;
  }
  const content = state.stream.displayedLines.length
    ? esc(state.stream.displayedLines.join('\n'))
    : (state.stream.loading ? 'Connecting to run events...' : 'No output yet for this agent.');
  host.innerHTML = `
    <div class="term-wrap">
      <div class="term-head">
        <span>read-only terminal • ${esc(state.stream.agentId)}</span>
        <div class="term-actions">
          <span><span class="status-dot" style="background:${statusTone(state.stream.stepStatus)}"></span>${esc(prettyStatus(state.stream.stepStatus))}</span>
          <button class="term-copy" id="copyAgentOutputBtn" type="button">copy</button>
        </div>
      </div>
      <pre class="term-view">${content}</pre>
    </div>
  `;
  const term = host.querySelector('.term-view');
  if (term) term.scrollTop = term.scrollHeight;
  const copyBtn = host.querySelector('#copyAgentOutputBtn');
  if (copyBtn) {
    copyBtn.onclick = async () => {
      const lines = state.stream.displayedLines.length ? state.stream.displayedLines : state.stream.targetLines;
      const text = lines.length ? lines.join('\n') : 'No output yet for this agent.';
      try {
        await navigator.clipboard.writeText(text);
        copyBtn.textContent = 'copied';
      } catch {
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.setAttribute('readonly', 'true');
        ta.style.position = 'fixed';
        ta.style.left = '-9999px';
        document.body.appendChild(ta);
        ta.select();
        try { document.execCommand('copy'); copyBtn.textContent = 'copied'; }
        catch { copyBtn.textContent = 'copy failed'; }
        document.body.removeChild(ta);
      }
      setTimeout(() => { copyBtn.textContent = 'copy'; }, 1200);
    };
  }
}

function renderAgentStatusList(agents, run){
  const rows = agents.length
    ? agents.map(a => `
      <div class="agent-row ${(state.stream.agentId === a.agentId && state.stream.runId === run?.id && String(state.stream.stepId || '') === String(a.stepId || '')) ? 'active' : ''}" data-agent="${esc(a.agentId)}" data-step="${esc(a.stepId || '')}" data-run="${esc(run?.id || '')}">
        <div class="agent-meta"><span class="status-dot" style="background:${statusTone(a.status)}"></span><span class="agent-name" title="${esc(a.agentId)}">${esc(a.displayName || baseAgentId(a.agentId))}</span></div>
        <div class="agent-actions">
          <span class="badge">${esc(prettyStatus(a.status))}</span>
          ${canRestartAgentStatus(a.status)
            ? `<button class="agent-restart" data-restart-agent="${esc(a.agentId)}" data-restart-run="${esc(run?.id || '')}">restart</button>`
            : ''}
          ${baseAgentId(a.agentId).toLowerCase().endsWith('/developer') ? `<button class="agent-redo" data-redo-run="${esc(run?.id || '')}" title="Redo developer from failed test feedback (R)">redo</button>` : ''}
        </div>
      </div>`).join('')
    : '<div class="notice">No assigned agents yet.</div>';
  return `<div class="build-card" style="margin-top:8px"><div class="kv"><strong>Assigned Agents</strong></div><div class="agent-list" id="assignedAgentList">${rows}</div><div id="terminalViewerHost"></div></div>`;
}

function placeFeatureDraftFromPlan(plan, x, y, repo){
  dbg('planDrop:placeFeatureDraftFromPlan', { planId: String(plan?.id || ''), x, y, repo });
  const ok = !!placeFeatureAt(x, y, String(plan?.prompt || ''), String(repo || ''));
  dbg('planDrop:placeFeatureDraftFromPlan:result', { ok });
  return ok;
}

function consumeResearchPlan(repoKey, planId){
  dbg('planQueue:consume:start', { repoKey, planId });
  if (!repoKey || !planId) return null;
  const lab = primaryResearchLabForRepo(repoKey);
  if (!lab) return null;
  const list = Array.isArray(lab.plans) ? lab.plans : [];
  const idx = list.findIndex((p) => String(p.id) === String(planId));
  if (idx < 0) {
    dbg('planQueue:consume:miss', { repoKey, planId, size: list.length });
    return null;
  }
  const plan = list[idx];
  const next = [...list.slice(0, idx), ...list.slice(idx + 1)];
  lab.plans = next;
  queuePersist();
  dbg('planQueue:consume:ok', { repoKey, planId, remaining: next.length });
  return plan;
}

function consumeResearchPlanAny(planId, preferredRepoKey = ''){
  const labs = Array.isArray(state.researchBuildings) ? state.researchBuildings : [];
  dbg('planQueue:consumeAny:start', { planId, preferredRepoKey, labs: labs.map((l) => l.id) });
  const preferred = String(preferredRepoKey || '');
  if (preferred) {
    const plan = consumeResearchPlan(preferred, planId);
    if (plan) {
      dbg('planQueue:consumeAny:hit_preferred', { repoKey: preferred, planId });
      return { plan, repoKey: preferred };
    }
  }
  const keys = labs.map((l) => baseRepoKey(String(l.repo || ''))).filter(Boolean);
  for (const key of [...new Set(keys)]) {
    const plan = consumeResearchPlan(key, planId);
    if (plan) {
      dbg('planQueue:consumeAny:hit_fallback', { repoKey: key, planId });
      return { plan, repoKey: key };
    }
  }
  dbg('planQueue:consumeAny:miss', { planId });
  return null;
}

function renderUniversityPanel(targetId){
  renderResearchLabPanel(targetId);
}

function renderResearchLabPanel(targetLabId){
  const panel = document.getElementById('actionPanel');
  panel.dataset.mode = 'research';
  panel.dataset.featureId = '';
  const lab = (state.researchBuildings || []).find((it) => String(it.id) === String(targetLabId || ''))
    || (state.selected?.type === 'building' && isResearchKind(state.selected?.data?.kind) ? state.selected.data : null);
  if (!lab) {
    panel.innerHTML = `${panelToolbar('Research Console')}<div class="notice">Select a Research Lab to generate plans.</div>`;
    wirePanelDeleteButton();
    return;
  }
  const isUni = lab.kind === 'university';
  const requestedRepo = baseRepoKey(String(lab.repo || ''));
  const runtimeRepo = normalizePathKey(String(state.runtime?.cwd || ''));
  const effectiveRepo = (requestedRepo && requestedRepo !== 'workspace-repo') ? requestedRepo : runtimeRepo;
  const repoKey = effectiveRepo || requestedRepo || 'workspace-repo';
  const plans = (Array.isArray(lab.plans) ? lab.plans : [])
    .map((plan, idx) => normalizeResearchPlan(plan, `plan-${Date.now()}-${idx + 1}`));
  if (effectiveRepo && lab.repo !== effectiveRepo) {
    lab.repo = effectiveRepo;
    queuePersist();
  }
  panel.innerHTML = `
    ${panelToolbar(isUni ? 'University Console' : 'Research Console', String(effectiveRepo || requestedRepo || 'unlinked'))}
    <div class="kv"><strong>Repo:</strong> ${esc(effectiveRepo || requestedRepo || 'unlinked')}</div>
    <div class="kv"><strong>Worktree:</strong> ${esc(String(lab.worktreePath || effectiveRepo || requestedRepo || '-'))}</div>
    <button id="runResearchBtn">Research</button>
    <div class="notice" style="margin-top:8px" id="researchNotice">${isUni ? 'University generates planning artifacts and routes them to Library/Warehouse.' : 'Analyze repo via Antfarm planner agent. Deploy adds a plan to warehouse inventory; delete marks WONT FIX.'}</div>
    <div class="build-card" style="margin-top:8px">
      <div class="kv"><strong>Generated Plans</strong></div>
      <div id="researchPlanList">${plans.length ? plans.map((plan, idx) => `
        <div class="agent-row research-plan" ${String(plan.disposition || 'OPEN').toUpperCase() === 'WONT_FIX' ? '' : 'draggable="true"'} data-plan-id="${esc(plan.id)}">
          <div class="agent-meta">
            <span class="badge">${esc(String(plan.type || 'feature').toUpperCase())}</span>
            ${String(plan.disposition || 'OPEN').toUpperCase() === 'WONT_FIX' ? '<span class="badge">WONT FIX</span>' : ''}
            <span class="agent-name" title="${esc(plan.summary || '')}">${esc(plan.title || `Plan ${idx + 1}`)}</span>
          </div>
          <div class="agent-actions">
            <button class="agent-restart" data-plan-deploy="${esc(plan.id)}" ${String(plan.disposition || 'OPEN').toUpperCase() === 'WONT_FIX' ? 'disabled' : ''}>deploy</button>
            <button class="agent-restart" data-plan-wont-fix="${esc(plan.id)}" title="Mark WONT FIX">delete</button>
          </div>
        </div>
      `).join('') : '<div class="notice">No plans yet. Press Research.</div>'}</div>
      <div class="notice" style="margin-top:8px">Drag a plan onto the map to create a Feature draft, or deploy to store it in ${isUni ? 'Library or Warehouse' : 'Warehouse'}.</div>
    </div>
  `;
  wirePanelDeleteButton();
  const notice = document.getElementById('researchNotice');
  const refreshPlanInteractions = () => {
    const list = document.getElementById('researchPlanList');
    if (!list) return;
    list.querySelectorAll('[data-plan-deploy]').forEach((btn) => {
      btn.addEventListener('click', () => {
        const id = btn.getAttribute('data-plan-deploy');
        dbg('planDeploy:click', { id, repoKey });
        const plan = consumeResearchPlan(repoKey, String(id || ''));
        if (!plan) return;
        const queue = appendWarehouseItems(repoKey, [plan]);
        if (!queue.length) {
          const existing = Array.isArray(lab.plans) ? lab.plans : [];
          lab.plans = [plan, ...existing];
          queuePersist();
          dbg('planDeploy:restore_after_failed_store', { id, repoKey });
        }
        if (notice) notice.textContent = `Stored in warehouse: ${String(plan.title || plan.id)}. Items in queue: ${queue.length}.`;
        dbg('planDeploy:done', { id, stored: queue.length > 0, size: queue.length });
        rebuildScene();
        if (state.selected?.type === 'building' && isStorageKind(state.selected?.data?.kind)) {
          renderStoragePanelForBuilding(state.selected.data.id);
        }
        renderResearchLabPanel(lab.id);
      });
    });
    list.querySelectorAll('[data-plan-wont-fix]').forEach((btn) => {
      btn.addEventListener('click', () => {
        const id = btn.getAttribute('data-plan-wont-fix');
        if (!id) return;
        const changed = markResearchPlanWontFix(repoKey, id);
        dbg('planMutation:wont_fix', { id, repoKey, changed });
        renderResearchLabPanel(lab.id);
      });
    });
    list.querySelectorAll('.research-plan').forEach((row) => {
      row.addEventListener('dragstart', (e) => {
        const id = row.getAttribute('data-plan-id') || '';
        const plan = (Array.isArray(lab.plans) ? lab.plans : [])
          .map((x) => normalizeResearchPlan(x))
          .find((x) => String(x.id) === String(id));
        if (String(plan?.disposition || 'OPEN').toUpperCase() === 'WONT_FIX') {
          e.preventDefault();
          return;
        }
        queuedResearchPlan = { id, repoKey, repoPath: (effectiveRepo || requestedRepo) };
        dragBuildingType = 'feature';
        setPlacement('feature');
        dragResearchPlan = null;
        researchDropHandled = false;
        lastResearchDragSnap = null;
        e.dataTransfer?.setData('text/plain', 'feature');
        dbg('planDrag:start', { id, repoKey, repoPath: queuedResearchPlan.repoPath, types: e.dataTransfer?.types ? Array.from(e.dataTransfer.types) : [] });
        worldWrapEl.classList.add('drop-armed');
      });
      row.addEventListener('dragend', () => {
        dbg('planDrag:end', { queuedResearchPlan, dragResearchPlan, dragBuildingType });
        if (!researchDropHandled && queuedResearchPlan && lastResearchDragSnap) {
          dbg('planDrag:end:fallbackCommit', { queuedResearchPlan, lastResearchDragSnap });
          commitQueuedResearchPlan(lastResearchDragSnap);
        }
        queuedResearchPlan = null;
        dragResearchPlan = null;
        dragBuildingType = null;
        setPlacement(null);
        researchDropHandled = false;
        lastResearchDragSnap = null;
        worldWrapEl.classList.remove('drop-armed');
        hidePlacementGhost();
      });
    });
  };
  refreshPlanInteractions();
  const runBtn = document.getElementById('runResearchBtn');
  runBtn?.addEventListener('click', async () => {
    try {
      if (!effectiveRepo) throw new Error('No repo resolved for research. Place lab near a base with a repo, or run RTS from an Antfarm repo.');
      if (notice) notice.textContent = 'Running planner agent and generating plans...';
      const res = await postJson('/api/rts/research/generate', { repoPath: effectiveRepo, maxPlans: 10 });
      const nextPlans = appendResearchPlans(repoKey, Array.isArray(res.plans) ? res.plans : []);
      if (notice) {
        const count = Array.isArray(res.plans) ? res.plans.length : 0;
        notice.textContent = `Added ${count} plan(s), total ${nextPlans.length}, from ${res.repoPath || effectiveRepo}. Drag one onto the map or deploy directly.`;
      }
      renderResearchLabPanel(lab.id);
    } catch (err) {
      if (notice) notice.textContent = `Research failed: ${err.message || err}`;
    }
  });
}

function renderWarehousePanel(targetWarehouseId){
  const panel = document.getElementById('actionPanel');
  panel.dataset.mode = 'warehouse';
  panel.dataset.featureId = '';
  const warehouse = (state.warehouseBuildings || []).find((it) => String(it.id) === String(targetWarehouseId || ''))
    || (state.selected?.type === 'building' && state.selected?.data?.kind === 'warehouse' ? state.selected.data : null);
  if (!warehouse) {
    panel.innerHTML = `${panelToolbar('Warehouse Console')}<div class="notice">Select a Warehouse.</div>`;
    wirePanelDeleteButton();
    return;
  }
  const repoKey = baseRepoKey(String(warehouse.repo || ''));
  const items = (Array.isArray(warehouse.items) ? warehouse.items : [])
    .map((plan, idx) => normalizeResearchPlan(plan, `warehouse-plan-${idx + 1}`));
  const nearestLab = (state.researchBuildings || [])
    .filter((rb) => rb.kind === 'research' && baseRepoKey(String(rb.repo || '')) === repoKey)
    .reduce((best, rb) => {
      const a = centerPointFor('warehouse', Number(warehouse.x || 0), Number(warehouse.y || 0));
      const b = centerPointFor('research', Number(rb.x || 0), Number(rb.y || 0));
      const d = Math.hypot(a.x - b.x, a.y - b.y);
      if (!best || d < best.dist) return { rb, dist: d };
      return best;
    }, null)?.rb || null;
  const nearestFeature = (state.buildings || [])
    .filter((fb) => fb.kind === 'feature' && baseRepoKey(String(fb.repo || '')) === repoKey)
    .reduce((best, fb) => {
      const a = centerPointFor('warehouse', Number(warehouse.x || 0), Number(warehouse.y || 0));
      const b = centerPointFor('feature', Number(fb.x || 0), Number(fb.y || 0));
      const d = Math.hypot(a.x - b.x, a.y - b.y);
      if (!best || d < best.dist) return { fb, dist: d };
      return best;
    }, null)?.fb || null;

  panel.innerHTML = `
    ${panelToolbar('Warehouse Console', String(repoKey || 'unlinked'))}
    <div class="kv"><strong>Repo:</strong> ${esc(repoKey || 'unlinked')}</div>
    <div class="kv"><strong>Worktree:</strong> ${esc(String(warehouse.worktreePath || repoKey || '-'))}</div>
    <div class="kv"><strong>Input:</strong> ${esc(nearestLab ? `Research Lab ${nearestLab.id}` : 'none')}</div>
    <div class="kv"><strong>Output:</strong> ${esc(nearestFeature ? `Feature ${nearestFeature.id}` : 'none')}</div>
    <div class="notice" id="warehouseNotice">When a feature is marked EMPTY (after PR merge), it pulls the most important stored item.</div>
    <div class="build-card" style="margin-top:8px">
      <div class="kv"><strong>Stored Items</strong></div>
      <div>${items.length ? items.map((plan, idx) => `
        <div class="agent-row">
          <div class="agent-meta">
            <span class="badge">${esc(String(plan.type || 'feature').toUpperCase())}</span>
            <span class="agent-name" title="${esc(plan.summary || '')}">${esc(plan.title || `Item ${idx + 1}`)}</span>
          </div>
        </div>
      `).join('') : '<div class="notice">Warehouse is empty.</div>'}</div>
    </div>
  `;
  wirePanelDeleteButton();
}

async function renderPowerPlantPanel(targetWarehouseId){
  const panel = document.getElementById('actionPanel');
  panel.dataset.mode = 'power';
  panel.dataset.featureId = '';
  const plant = (state.warehouseBuildings || []).find((it) => String(it.id) === String(targetWarehouseId || ''))
    || (state.selected?.type === 'building' && state.selected?.data?.kind === 'power' ? state.selected.data : null);
  if (!plant) {
    panel.innerHTML = `${panelToolbar('Power Plant Console')}<div class="notice">Select a Power Plant.</div>`;
    wirePanelDeleteButton();
    return;
  }
  await refreshRuntimeState(false);
  const repoKey = baseRepoKey(String(plant.repo || ''));
  const jobsRaw = Array.isArray(state.diag?.cron?.jobs) ? state.diag.cron.jobs : [];
  const jobs = jobsRaw.map((job) => ({
    name: String(job?.name || ''),
    schedule: String(job?.schedule || ''),
    enabled: job?.enabled !== false,
    nextRunAtMs: Number(job?.nextRunAtMs || 0) || 0,
    lastRunAtMs: Number(job?.lastRunAtMs || 0) || 0,
    lastStatus: String(job?.lastStatus || '')
  }));
  const fmt = (tsMs) => {
    const n = Number(tsMs || 0);
    return n > 0 ? new Date(n).toLocaleString() : 'n/a';
  };
  panel.innerHTML = `
    ${panelToolbar('Power Plant Console', String(repoKey || 'unlinked'))}
    <div class="notice">Opening full-screen power plant console...</div>
  `;
  wirePanelDeleteButton();
  let modal = document.getElementById('powerModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'powerModal';
    modal.className = 'library-modal';
    document.body.appendChild(modal);
  }
  modal.hidden = false;
  modal.innerHTML = `
    <div class="library-modal-header">
      <div>
        <strong>Power Plant Console</strong>
        <div class="notice">${esc(repoKey || 'unlinked')} • ${jobs.length} cron jobs</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
        <button id="powerRefreshBtn">Refresh Jobs</button>
        <button id="powerCloseBtn" class="ghost">Close</button>
      </div>
    </div>
    <div class="library-modal-body" style="grid-template-columns:1fr">
      <div class="library-preview" style="grid-column:1">
        <div class="library-preview-head">Cron Jobs</div>
        <div style="display:grid;gap:8px;padding:6px 0;max-height:64vh;overflow:auto">
          ${jobs.length ? jobs.map((job) => `
            <div class="build-card">
              <div class="agent-row">
                <div class="agent-meta">
                  <span class="badge">${job.enabled ? 'ENABLED' : 'DISABLED'}</span>
                  <span class="agent-name" title="${esc(job.schedule || 'no schedule')}">${esc(job.name || '(unnamed)')}</span>
                </div>
                <div class="agent-actions">
                  <span class="badge">${esc(job.lastStatus || 'idle')}</span>
                </div>
              </div>
              <div class="kv"><strong>Schedule:</strong> ${esc(job.schedule || 'n/a')}</div>
              <div class="kv"><strong>Last run:</strong> ${esc(fmt(job.lastRunAtMs))}</div>
              <div class="kv"><strong>Next run:</strong> ${esc(fmt(job.nextRunAtMs))}</div>
            </div>
          `).join('') : '<div class="notice">No cron jobs found.</div>'}
        </div>
      </div>
    </div>
  `;
  document.getElementById('powerRefreshBtn')?.addEventListener('click', () => {
    void renderPowerPlantPanel(plant.id);
  });
  document.getElementById('powerCloseBtn')?.addEventListener('click', () => {
    modal.hidden = true;
  });
}

async function renderLibraryPanel(targetWarehouseId){
  const panel = document.getElementById('actionPanel');
  panel.dataset.mode = 'library';
  panel.dataset.featureId = '';
  const warehouse = (state.warehouseBuildings || []).find((it) => String(it.id) === String(targetWarehouseId || ''))
    || (state.selected?.type === 'building' && state.selected?.data?.kind === 'library' ? state.selected.data : null);
  if (!warehouse) {
    panel.innerHTML = `${panelToolbar('Library Console')}<div class="notice">Select a Library.</div>`;
    wirePanelDeleteButton();
    return;
  }
  const repoKey = baseRepoKey(String(warehouse.repo || ''));
  const view = state.libraryBrowser || { role: 'all', tag: 'all', q: '', selectedPath: '' };
  panel.innerHTML = `
    ${panelToolbar('Library Console', String(repoKey || 'unlinked'))}
    <div class="notice">Opening full-screen library browser...</div>
  `;
  wirePanelDeleteButton();
  try {
    const role = String(view.role || 'all');
    const tag = String(view.tag || 'all');
    const q = String(view.q || '');
    const params = new URLSearchParams();
    params.set('role', role);
    params.set('tag', tag);
    if (q) params.set('q', q);
    params.set('max', '5000');
    const res = await json(`/api/rts/library/files?${params.toString()}`);
    const tags = Array.isArray(res?.tags) ? res.tags.map((x) => String(x || '')).filter(Boolean) : [];
    const files = Array.isArray(res?.files) ? res.files : [];
    const roleOptions = ['all', 'planner', 'setup', 'developer', 'verifier', 'tester', 'reviewer'];
    const shown = files.slice(0, 800);
    const selectedRole = role;
    const prioritized = selectedRole === 'all'
      ? shown
      : shown.filter((f) => Array.isArray(f?.roles) && f.roles.map((x) => String(x || '')).includes(selectedRole));
    const rest = selectedRole === 'all'
      ? []
      : shown.filter((f) => !(Array.isArray(f?.roles) && f.roles.map((x) => String(x || '')).includes(selectedRole)));
    const selectedPath = String(view.selectedPath || (prioritized[0]?.absPath || shown[0]?.absPath || ''));

    let modal = document.getElementById('libraryModal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'libraryModal';
      modal.className = 'library-modal';
      document.body.appendChild(modal);
    }
    modal.hidden = false;
    modal.innerHTML = `
      <div class="library-modal-header">
        <div>
          <strong>Library Console</strong>
          <div class="notice">${esc(repoKey || 'unlinked')} • ${shown.length} files</div>
        </div>
        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <label class="kv">Role
            <select id="libraryRoleFilter">${roleOptions.map((r) => `<option value="${esc(r)}"${r === role ? ' selected' : ''}>${esc(r)}</option>`).join('')}</select>
          </label>
          <label class="kv">Tag
            <select id="libraryTagFilter"><option value="all">all</option>${tags.map((t) => `<option value="${esc(t)}"${t === tag ? ' selected' : ''}>${esc(t)}</option>`).join('')}</select>
          </label>
          <label class="kv">Search
            <input id="librarySearchInput" value="${esc(q)}" placeholder="AGENTS, memory, verifier" />
          </label>
          <button id="libraryApplyBtn">Apply</button>
          <button id="libraryResetBtn" class="ghost">Reset</button>
          <button id="libraryCloseBtn" class="ghost">Close</button>
        </div>
      </div>
      <div class="library-modal-body">
        <div class="library-file-list" id="libraryFileList">
          ${prioritized.length ? prioritized.map((f) => {
            const p = String(f?.path || '');
            const absPath = String(f?.absPath || '');
            const fileTags = Array.isArray(f?.tags) ? f.tags.map((x) => String(x || '')).filter(Boolean) : [];
            const fileRoles = Array.isArray(f?.roles) ? f.roles.map((x) => String(x || '')).filter(Boolean) : [];
            return `<button class="library-file-row ${absPath === selectedPath ? 'active' : ''}" data-library-path="${esc(absPath)}"><span class="library-file-name">${esc(p || absPath || 'unknown')}</span><span class="library-file-meta">${esc(formatBytes(Number(f?.size || 0)))} • ${esc(fileRoles.join(', ') || 'all roles')} • ${esc(fileTags.join(' • ') || 'md')}</span></button>`;
          }).join('') : '<div class="notice">No worker-priority files for this role.</div>'}
          ${rest.length ? `<div class="library-split"><div class="notice">Other visible files</div></div>${rest.map((f) => {
            const p = String(f?.path || '');
            const absPath = String(f?.absPath || '');
            const fileTags = Array.isArray(f?.tags) ? f.tags.map((x) => String(x || '')).filter(Boolean) : [];
            const fileRoles = Array.isArray(f?.roles) ? f.roles.map((x) => String(x || '')).filter(Boolean) : [];
            return `<button class="library-file-row ${absPath === selectedPath ? 'active' : ''}" data-library-path="${esc(absPath)}"><span class="library-file-name">${esc(p || absPath || 'unknown')}</span><span class="library-file-meta">${esc(formatBytes(Number(f?.size || 0)))} • ${esc(fileRoles.join(', ') || 'all roles')} • ${esc(fileTags.join(' • ') || 'md')}</span></button>`;
          }).join('')}` : ''}
        </div>
        <div class="library-preview">
          <div class="library-preview-head" id="libraryPreviewHead">${esc(selectedPath || 'Select a file')}</div>
          <textarea id="libraryPreviewText" spellcheck="false" placeholder="Select a markdown file from the list."></textarea>
        </div>
      </div>
    `;

    const loadFile = async (absPath) => {
      const pth = String(absPath || '').trim();
      if (!pth) return;
      state.libraryBrowser = { ...state.libraryBrowser, selectedPath: pth };
      const head = document.getElementById('libraryPreviewHead');
      const ta = document.getElementById('libraryPreviewText');
      if (head) head.textContent = pth;
      if (ta) ta.value = 'Loading...';
      try {
        const fileRes = await json(`/api/rts/library/file?path=${encodeURIComponent(pth)}`);
        if (head) head.textContent = String(fileRes?.path || pth);
        if (ta) ta.value = String(fileRes?.content || '');
      } catch (err) {
        if (ta) ta.value = `Failed to load file:\n${String(err?.message || err || 'unknown error')}`;
      }
      modal.querySelectorAll('.library-file-row').forEach((row) => {
        row.classList.toggle('active', String(row.getAttribute('data-library-path') || '') === pth);
      });
    };

    const apply = () => {
      state.libraryBrowser = {
        role: String(document.getElementById('libraryRoleFilter')?.value || 'all'),
        tag: String(document.getElementById('libraryTagFilter')?.value || 'all'),
        q: String(document.getElementById('librarySearchInput')?.value || '').trim(),
        selectedPath: String(state.libraryBrowser?.selectedPath || ''),
      };
      void renderLibraryPanel(warehouse.id);
    };
    modal.querySelectorAll('.library-file-row').forEach((row) => {
      row.addEventListener('click', () => {
        const pth = String(row.getAttribute('data-library-path') || '');
        void loadFile(pth);
      });
    });
    document.getElementById('libraryApplyBtn')?.addEventListener('click', apply);
    document.getElementById('libraryRoleFilter')?.addEventListener('change', apply);
    document.getElementById('libraryTagFilter')?.addEventListener('change', apply);
    document.getElementById('librarySearchInput')?.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        apply();
      }
    });
    document.getElementById('libraryResetBtn')?.addEventListener('click', () => {
      state.libraryBrowser = { role: 'all', tag: 'all', q: '', selectedPath: '' };
      void renderLibraryPanel(warehouse.id);
    });
    document.getElementById('libraryCloseBtn')?.addEventListener('click', () => { modal.hidden = true; });
    if (selectedPath) void loadFile(selectedPath);
  } catch (err) {
    panel.innerHTML = `
      ${panelToolbar('Library Console', String(repoKey || 'unlinked'))}
      <div class="notice">Library index failed: ${esc(String(err?.message || err || 'unknown error'))}</div>
    `;
    wirePanelDeleteButton();
  }
}

function renderRunSetupPanel(targetDraftId){
  const panel = document.getElementById('actionPanel');
  let draft = null;
  if (targetDraftId) {
    draft = state.featureBuildings.find(d => d.id === targetDraftId) || null;
  } else if (state.selected?.type === 'building' && state.selected?.data?.kind === 'feature') {
    const selectedId = String(state.selected?.data?.id || '');
    draft = state.featureBuildings.find(d => d.id === selectedId) || null;
  }
  if (!draft && targetDraftId) {
    const inferred = (state.buildings || []).find((b) => b.id === targetDraftId && b.kind === 'feature');
    if (inferred) {
      draft = {
        id: inferred.id,
        kind: 'feature',
        phase: inferred.phase || inferred.run?.status || 'running',
        committed: !!(inferred.committed || inferred.runId),
        runId: inferred.runId || inferred.run?.id || null,
        x: inferred.x,
        y: inferred.y,
        repo: inferred.repo || '',
        baseId: String(inferred.baseId || ''),
        worktreePath: inferred.worktreePath || '',
        port: Number(inferred.port) || getPortForPath(inferred.worktreePath || inferred.repo || '') || nextSpreadPort(3334),
        prompt: inferred.run?.task || '',
        workerAssignments: (inferred.workerAssignments && typeof inferred.workerAssignments === 'object') ? inferred.workerAssignments : {},
        empty: !!inferred.empty,
      };
      state.featureBuildings.push(draft);
      queuePersist();
    }
  }
  if (!draft) {
    panel.dataset.mode = 'default';
    panel.dataset.featureId = '';
    setFeatureMode(false);
    panel.innerHTML = `${panelToolbar(`Command Console ${COMMAND_CONSOLE_VERSION}`, state.placementMode ? `Placement: ${state.placementMode}` : 'Idle')}<div class="notice">Use command cards to place Base, Feature Request, Research Lab, Warehouse, University, Library, or Power Plant structures.</div>`;
    wirePanelDeleteButton();
    panel.scrollTop = 0;
    stopAgentStream();
    return;
  }
  panel.dataset.mode = 'feature';
  panel.dataset.featureId = String(draft.id || '');
  setFeatureMode(true);
  if (!draft.worktreePath) draft.worktreePath = getWorktreeDefault(draft.repo || 'antfarm', draft.id || 'feature');
  if (typeof draft.prompt !== 'string') draft.prompt = String(draft.prompt || '');
  draft.empty = !!draft.empty;
  const base = findBaseForFeature(draft);
  if (base?.id && String(draft.baseId || '') !== String(base.id)) draft.baseId = String(base.id);
  const workerStats = base ? deriveBaseWorkerStats(base) : [];
  const requiredRoles = workflowRequiredRoles('feature-dev').filter((role) => WORKER_ROLES.includes(role));
  const workerHealth = requiredRoles.map((role) => workerStats.find((r) => r.role === role) || { role, total: 0, busy: 0, idle: 0 });
  const missingRoles = workerHealth.filter((r) => Number(r.idle || 0) <= 0).map((r) => r.role);
  const run = draft.runId ? (state.runs || []).find(r => r.id === draft.runId) : null;
  const hasRun = !!run;
  const runAgents = hasRun ? deriveRunAgents(run) : [];
  const allAgentsCompleted = runAgents.length > 0 && runAgents.every((a) => {
    const s = String(a?.status || '').toLowerCase();
    return s === 'done' || s === 'skipped';
  });
  const isDraft = !draft.committed;
  const freeReady = canMarkFeatureEmpty({ ...draft, run, prUrl: extractPrUrl(run) || draft.prUrl });
  const freeLabel = draft.empty ? 'Set Filled' : (freeReady ? 'Set Free (PR ready)' : 'Set Free (PR pending)');
  if (!draft.port) {
    draft.port = getPortForPath(draft.worktreePath || '') || getPortForPath(draft.repo || '') || nextSpreadPort(3334);
  }

  panel.innerHTML = `
    ${panelToolbar(isDraft ? 'Feature Draft Setup' : 'Feature Run Console', String(draft.id || ''))}
    <div class="kv"><strong>Repo:</strong> ${esc(draft.repo)}</div>
    <div class="kv"><strong>Base scope:</strong> ${esc(base?.id || 'none')}</div>
    ${allAgentsCompleted ? `<button id="markFeatureEmptyBtn" style="margin:4px 0 8px 0" ${freeReady || draft.empty ? '' : 'disabled'}>${freeLabel}</button>` : ''}
    <label class="kv">Worktree path
      <input id="worktreePath" value="${esc(draft.worktreePath)}" />
    </label>
    <div class="kv"><strong>Runtime:</strong> ${runtimeLink(draft.port || 3334)}</div>
    <div class="kv"><strong>Empty:</strong> ${draft.empty ? 'yes' : 'no'}</div>
    ${isDraft
      ? `<label class="kv">Feature prompt
      <textarea id="featurePrompt" rows="8" placeholder="Describe detailed scope, constraints, and acceptance criteria...">${esc(draft.prompt)}</textarea>
    </label>`
      : `<div class="kv"><strong>Feature prompt:</strong></div>
    <div class="build-card" style="margin-top:6px"><div class="prompt-text">${esc(String(draft.prompt || run?.task || ''))}</div></div>`}
    ${hasRun ? renderAgentStatusList(runAgents, run) : ''}
    <button id="launchFeatureRunBtn" style="margin-top:8px" ${String(draft.repo || '').trim() ? '' : 'disabled'}>${isDraft ? 'Create Worktree + Start Run' : 'Relaunch Run'}</button>
    <button id="preparePrBtn" style="margin-top:6px">Check / Prepare PR Link</button>
    <div class="notice" style="margin-top:8px" id="featureMutationNotice">${missingRoles.length ? `Blocked: no idle ${missingRoles.join(', ')} workers in base ${base?.id || 'unknown'}.` : 'Ready to execute backend actions.'}</div>
  `;
  wirePanelDeleteButton();
  panel.scrollTop = 0;

  document.getElementById('worktreePath').addEventListener('input', e => { draft.worktreePath = e.target.value; queuePersist(); });
  const featurePromptInput = document.getElementById('featurePrompt');
  if (featurePromptInput) {
    featurePromptInput.addEventListener('input', e => {
      draft.prompt = e.target.value;
      void postJson('/api/rts/layout/position', {
        entityType: 'feature',
        entityId: draft.id,
        runId: draft.runId || null,
        repoPath: draft.repo || null,
        worktreePath: draft.worktreePath || null,
        x: Number(draft.x || 0),
        y: Number(draft.y || 0),
        payload: {
          baseId: String(draft.baseId || ''),
          workerAssignments: draft.workerAssignments || {},
          prompt: String(draft.prompt || '')
        }
      }).catch(() => {});
      queuePersist();
    });
  }
  const mutationNotice = document.getElementById('featureMutationNotice');
  let launchInFlight = false;

  const reserveFreshWorktreeAndPort = () => {
    const nowToken = `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 6)}`;
    const repoKey = String(draft.repo || 'repo');
    draft.worktreePath = getWorktreeDefault(repoKey, `${draft.id || 'feature'}:${nowToken}`);
    let nextPort = Number(getPortForPath(draft.worktreePath || '')) || nextSpreadPort(3334);
    nextPort = nextSpreadPort(nextPort);
    draft.port = nextPort;
    setPortForPath(draft.worktreePath, nextPort);
  };

  const startFeatureRun = async () => {
    if (launchInFlight) return false;
    const resolvedBase = findBaseForFeature(draft);
    if (resolvedBase?.id) draft.baseId = String(resolvedBase.id);
    const allocation = resolvedBase ? allocateWorkersForBase(resolvedBase, 'feature-dev') : { assignments: {}, missing: [] };
    const fallbackAssignments = {};
    requiredRoles.forEach((role) => {
      fallbackAssignments[role] = `${role}-1`;
    });
    draft.workerAssignments = { ...fallbackAssignments, ...allocation.assignments, ...(draft.workerAssignments || {}) };
    const effectiveRepo = String(draft.repo || resolvedBase?.repo || '').trim();
    if (!effectiveRepo) {
      mutationNotice.textContent = 'Cannot launch: factory repo path is missing.';
      return false;
    }
    draft.repo = effectiveRepo;
    launchInFlight = true;
    const launchBtn = document.getElementById('launchFeatureRunBtn');
    if (launchBtn) launchBtn.disabled = true;
    try {
      mutationNotice.textContent = 'Creating worktree + starting workflow run...';
      const branchName = `feature/${(draft.prompt || 'task').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'').slice(0,32) || 'task'}-${Date.now().toString().slice(-5)}`;
      const previousRunId = draft.runId || null;
      const draftId = String(draft.id || '');
      const draftX = Number(draft.x || 0);
      const draftY = Number(draft.y || 0);
      const runResult = await postJson('/api/rts/feature/run', {
        workflowId: 'feature-dev',
        taskTitle: draft.prompt || `Feature request for ${draft.repo}`,
        prompt: draft.prompt,
        baseRepoPath: effectiveRepo,
        baseId: draft.baseId || '',
        workerAssignments: draft.workerAssignments || {},
        worktreePath: draft.worktreePath,
        branchName,
        draftId,
        draftX,
        draftY,
        draftPort: Number(draft.port || 0) || null
      });

      const latestRuns = await json('/api/runs');
      let launchedRunId = String(runResult?.run?.id || '');
      const launchedWorktree = absolutizePath(String(runResult?.worktreePath || draft.worktreePath || ''), String(draft.repo || ''));
      const layoutEntityId = String(runResult?.layout?.id || draftId || draft.id || '');
      if (layoutEntityId) draft.id = layoutEntityId;
      if (!launchedRunId) {
        const matchedRun = (latestRuns || []).find((r) => {
          const ctx = parseContext(r);
          const runWt = absolutizePath(String(ctx.worktreePath || ''), String(ctx.baseRepoPath || ctx.repoPath || ''));
          return !!runWt && !!launchedWorktree && runWt === launchedWorktree;
        });
        if (matchedRun?.id) launchedRunId = String(matchedRun.id);
      }
      draft.worktreePath = runResult.worktreePath || draft.worktreePath;
      draft.port = Number(draft.port) || getPortForPath(draft.worktreePath || '') || nextSpreadPort(3334);
      setPortForPath(draft.worktreePath, draft.port);
      draft.runId = launchedRunId || draft.runId;
      draft.phase = 'running';
      draft.committed = true;
      draft.empty = false;
      draft.baseId = draft.baseId || resolvedBase?.id || '';
      draft.x = draftX;
      draft.y = draftY;
      state.featureBuildings = (state.featureBuildings || []).filter((fb) => {
        if (fb === draft) return true;
        if (!fb) return false;
        const sameRun = launchedRunId && String(fb.runId || '') === launchedRunId;
        if (sameRun) return false;
        const fbWt = absolutizePath(String(fb.worktreePath || ''), String(fb.repo || ''));
        const sameWorktreeDraft = !String(fb.runId || '') && !!launchedWorktree && fbWt === launchedWorktree;
        return !sameWorktreeDraft;
      });
      if (previousRunId && previousRunId !== draft.runId && state.runLayoutOverrides && typeof state.runLayoutOverrides === 'object') {
        delete state.runLayoutOverrides[previousRunId];
      }
      const runLabel = launchedRunId ? launchedRunId.slice(0, 12) : 'pending';
      mutationNotice.textContent = `Run started: ${runLabel} (${runResult.branchName})`;
      await persistNow();
      state.runs = latestRuns;
      rebuildScene();
      return true;
    } catch (err) {
      mutationNotice.textContent = `Error: ${err.message || err}`;
      return false;
    } finally {
      launchInFlight = false;
      const btn = document.getElementById('launchFeatureRunBtn');
      if (btn) btn.disabled = false;
    }
  };

  document.getElementById('markFeatureEmptyBtn')?.addEventListener('click', async () => {
    const runForDraft = draft.runId ? (state.runs || []).find(r => r.id === draft.runId) : null;
    const current = { ...draft, run: runForDraft, prUrl: extractPrUrl(runForDraft) || draft.prUrl };
    if (!draft.empty && !canMarkFeatureEmpty(current)) {
      mutationNotice.textContent = 'Set Free is available once run succeeds and PR is ready.';
      return;
    }
    if (draft.empty) {
      draft.empty = false;
      mutationNotice.textContent = 'Factory set to filled.';
      queuePersist();
      rebuildScene();
      renderRunSetupPanel(draft.id);
      return;
    }
    draft.empty = true;
    const refill = refillFeatureFromWarehouse(draft);
    if (refill.ok) {
      mutationNotice.textContent = `Factory set free and pulled from warehouse: ${String(refill.plan?.title || refill.plan?.id || 'item')}. Launching...`;
      reserveFreshWorktreeAndPort();
      draft.committed = false;
      draft.runId = null;
      draft.phase = 'draft';
      await startFeatureRun();
      return;
    } else {
      mutationNotice.textContent = `Factory set free. Pull pending: ${refill.reason}.`;
    }
    queuePersist();
    rebuildScene();
    renderRunSetupPanel(draft.id);
  });
  document.getElementById('launchFeatureRunBtn').addEventListener('click', async () => {
    await startFeatureRun();
  });

  document.getElementById('preparePrBtn').addEventListener('click', async () => {
    try {
      const latestRun = draft.runId ? (state.runs || []).find(r => r.id === draft.runId) : null;
      if (!latestRun) throw new Error('No run found for this draft/repo yet.');
      mutationNotice.textContent = 'Checking PR status...';
      const pr = await fetch('/api/pr/prepare', {
        method:'POST',
        headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify({ runId: latestRun.id })
      }).then(async (r) => ({ ok:r.ok, data: await r.json() }));
      if (pr.ok && pr.data?.prUrl) mutationNotice.textContent = `PR detected: ${pr.data.prUrl}`;
      else mutationNotice.textContent = pr.data?.next ? `PR waiting: ${pr.data.next}` : `PR status: ${pr.data?.error || 'unknown'}`;
    } catch (err) {
      mutationNotice.textContent = `Error: ${err.message || err}`;
    }
  });

  if (hasRun) {
    const agentRows = panel.querySelectorAll('#assignedAgentList .agent-row');
    agentRows.forEach(row => {
      row.addEventListener('click', () => {
        const runId = row.getAttribute('data-run');
        const agentId = row.getAttribute('data-agent');
        const stepId = row.getAttribute('data-step') || '';
        if (!runId || !agentId) return;
        state.streamSelectionByRun[runId] = streamSelectionKey(agentId, stepId);
        startAgentStream(runId, agentId, stepId);
        panel.querySelectorAll('#assignedAgentList .agent-row').forEach(r => r.classList.remove('active'));
        row.classList.add('active');
      });
    });
    const restartBtns = panel.querySelectorAll('#assignedAgentList .agent-restart');
    restartBtns.forEach((btn) => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const runId = btn.getAttribute('data-restart-run');
        const agentId = btn.getAttribute('data-restart-agent');
        if (!runId || !agentId) return;
        try {
          btn.disabled = true;
          if (mutationNotice) mutationNotice.textContent = `Restart requested for ${agentId}...`;
          const rr = await postJson('/api/rts/agent/restart', { runId, agentId });
          state.runs = await json('/api/runs');
          rebuildScene();
          renderRunSetupPanel(draft.id);
          const mutationNotice = document.getElementById('featureMutationNotice');
          if (mutationNotice) mutationNotice.textContent = rr?.kicked
            ? `Restart accepted for ${agentId}. Step reset and kick sent.`
            : `Restart accepted for ${agentId}. Step reset; waiting for cron fallback.`;
        } catch (err) {
          const message = String(err?.message || err || 'unknown_error');
          const human = message.includes('agent_waiting_not_restartable')
            ? 'Restart rejected: this agent is waiting. Restart a running/failed/done agent instead.'
            : `Restart failed: ${message}`;
          const mutationNotice = document.getElementById('featureMutationNotice');
          if (mutationNotice) mutationNotice.textContent = human;
        } finally {
          btn.disabled = false;
        }
      });
    });
    const redoBtns = panel.querySelectorAll('#assignedAgentList .agent-redo');
    redoBtns.forEach((btn) => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const runId = btn.getAttribute('data-redo-run');
        if (!runId) return;
        try {
          btn.disabled = true;
          const mutationNotice = document.getElementById('featureMutationNotice');
          if (mutationNotice) mutationNotice.textContent = 'Redoing Developer from failed test feedback...';
          const rr = await postJson('/api/rts/agent/redo-developer', { runId });
          markRunRelaunched(runId);
          rebuildScene();
          state.runs = await json('/api/runs');
          rebuildScene();
          renderRunSetupPanel(draft.id);
          if (mutationNotice) mutationNotice.textContent = rr?.kicked
            ? `Developer redo queued (story ${rr?.storyId || 'rerun'}), kicked immediately.`
            : `Developer redo queued (story ${rr?.storyId || 'rerun'}); waiting for cron fallback.`;
        } catch (err) {
          const mutationNotice = document.getElementById('featureMutationNotice');
          if (mutationNotice) mutationNotice.textContent = `Redo failed: ${err.message || err}`;
        } finally {
          btn.disabled = false;
        }
      });
    });
    renderTerminalViewer();
    const activeRow = panel.querySelector('#assignedAgentList .agent-row .badge')?.closest('.agent-row');
    const runningRow = [...agentRows].find((row) => (row.textContent || '').toLowerCase().includes('running'));
    const currentSelection = state.stream.runId === run.id
      ? streamSelectionKey(state.stream.agentId, state.stream.stepId || '')
      : '';
    const pinnedSelection = parseStreamSelectionKey(state.streamSelectionByRun[run.id] || currentSelection);
    const pinnedRow = pinnedSelection.agentId
      ? panel.querySelector(
        pinnedSelection.stepId
          ? `#assignedAgentList .agent-row[data-agent="${CSS.escape(pinnedSelection.agentId)}"][data-step="${CSS.escape(pinnedSelection.stepId)}"]`
          : `#assignedAgentList .agent-row[data-agent="${CSS.escape(pinnedSelection.agentId)}"]`
      )
      : null;
    const preferred = pinnedRow || runningRow || activeRow || agentRows[0];
    if (preferred) {
      const runId = preferred.getAttribute('data-run');
      const agentId = preferred.getAttribute('data-agent');
      const stepId = preferred.getAttribute('data-step') || '';
      if (!(runId && agentId && state.stream.runId === runId && state.stream.agentId === agentId && String(state.stream.stepId || '') === String(stepId || ''))) preferred.click();
    }
  } else {
    stopAgentStream();
  }
}

// controls
const worldEl = document.getElementById('world');
const worldWrapEl = document.getElementById('worldWrap');
const placementLayerEl = document.getElementById('placementLayer');
let dragBuildingType = null;
let dragResearchPlan = null;
let queuedResearchPlan = null;
let researchDropHandled = false;
let lastResearchDragSnap = null;
function hasResearchPlanMime(e){
  const types = e?.dataTransfer?.types;
  if (!types) return false;
  try {
    const has = Array.from(types).includes('application/x-antfarm-research-plan');
    dbg('planDrag:hasMime', { has, types: Array.from(types) });
    return has;
  } catch {
    return false;
  }
}

function commitResearchDropFromPayload(researchDrop, snapped){
  if (!researchDrop || !snapped) return false;
  const repoKey = String(researchDrop.repoKey || '');
  const repoPath = String(researchDrop.repoPath || '');
  const consumed = consumeResearchPlanAny(String(researchDrop.id || ''), repoKey);
  dbg('planDrop:commit:consumed', { researchDrop, consumedRepoKey: consumed?.repoKey, found: !!consumed?.plan, snapped });
  if (!consumed?.plan) return false;
  const effectiveRepoPath = repoPath || consumed.repoKey || '';
  const placed = placeFeatureDraftFromPlan(consumed.plan, snapped.x, snapped.y, effectiveRepoPath);
  dbg('planDrop:commit:placed', { placed, effectiveRepoPath });
  if (!placed) {
    const lab = primaryResearchLabForRepo(consumed.repoKey);
    const existing = Array.isArray(lab?.plans) ? lab.plans : [];
    if (lab) lab.plans = [consumed.plan, ...existing];
    queuePersist();
    return false;
  }
  researchDropHandled = true;
  if (state.selected?.type === 'building' && isResearchKind(state.selected?.data?.kind)) {
    if (state.selected.data.kind === 'university') renderUniversityPanel(state.selected.data.id);
    else renderResearchLabPanel(state.selected.data.id);
  }
  return true;
}
function commitQueuedResearchPlan(snapped){
  if (!queuedResearchPlan || !snapped) return false;
  const payload = queuedResearchPlan;
  dbg('planDrop:queued:commit:start', { payload, snapped });
  const consumed = consumeResearchPlanAny(String(payload.id || ''), String(payload.repoKey || ''));
  if (!consumed?.plan) {
    dbg('planDrop:queued:commit:miss', { payload });
    return false;
  }
  const effectiveRepoPath = String(payload.repoPath || consumed.repoKey || '');
  const placed = placeFeatureDraftFromPlan(consumed.plan, snapped.x, snapped.y, effectiveRepoPath);
  dbg('planDrop:queued:commit:placed', { placed, effectiveRepoPath });
  if (!placed) {
    const lab = primaryResearchLabForRepo(consumed.repoKey);
    const existing = Array.isArray(lab?.plans) ? lab.plans : [];
    if (lab) lab.plans = [consumed.plan, ...existing];
    queuePersist();
    return false;
  }
  if (state.selected?.type === 'building' && isResearchKind(state.selected?.data?.kind)) {
    if (state.selected.data.kind === 'university') renderUniversityPanel(state.selected.data.id);
    else renderResearchLabPanel(state.selected.data.id);
  }
  return true;
}
document.getElementById('cancelPlacementBtn')?.addEventListener('click', () => setPlacement(null));
document.getElementById('deleteSelectedBtn')?.addEventListener('click', () => deleteSelectedStructure());

// Placement must win over any entity drag/select path.
worldWrapEl.addEventListener('mousedown', (e) => {
  if (!state.placementMode) return;
  if (e.button !== 0) return;
  e.preventDefault();
  e.stopPropagation();
  const point = localPointInWorld(e);
  const snapped = snapPlacement(state.placementMode, point.x, point.y);
  if (state.placementMode === 'base') placeBaseAt(snapped.x, snapped.y);
  if (state.placementMode === 'feature') placeFeatureAt(snapped.x, snapped.y);
  if (state.placementMode === 'research') placeResearchAt(snapped.x, snapped.y);
  if (state.placementMode === 'warehouse') placeWarehouseAt(snapped.x, snapped.y);
  if (state.placementMode === 'university') placeUniversityAt(snapped.x, snapped.y);
  if (state.placementMode === 'library') placeLibraryAt(snapped.x, snapped.y);
  if (state.placementMode === 'power') placePowerAt(snapped.x, snapped.y);
  // Prevent the trailing click from immediately clearing fresh selection/panels.
  state.suppressWorldClick = true;
  setPlacement(null);
}, true);

document.querySelectorAll('.palette-card[data-building]').forEach((card) => {
  card.addEventListener('click', () => setPlacement(card.getAttribute('data-building')));
  card.addEventListener('dragstart', (e) => {
    const kind = card.getAttribute('data-building');
    dragBuildingType = kind;
    setPlacement(kind);
    e.dataTransfer?.setData('text/plain', kind || '');
    worldWrapEl.classList.add('drop-armed');
  });
  card.addEventListener('dragend', () => {
    dragBuildingType = null;
    worldWrapEl.classList.remove('drop-armed');
    hidePlacementGhost();
  });
});

worldWrapEl.addEventListener('dragover', (e) => {
  if (!dragBuildingType && !dragResearchPlan && !queuedResearchPlan && !hasResearchPlanMime(e)) return;
  e.preventDefault();
  const point = localPointInWorld(e);
  if (dragResearchPlan || queuedResearchPlan || hasResearchPlanMime(e)) {
    lastResearchDragSnap = snapPlacement('feature', point.x, point.y);
  }
  dbg('planDrop:dragover', { dragBuildingType, dragResearchPlan, queuedResearchPlan, x: point.x, y: point.y });
  showPlacementGhost(dragBuildingType || 'feature', point.x, point.y);
});
worldWrapEl.addEventListener('drop', (e) => {
  const plainData = String(e.dataTransfer?.getData('text/plain') || '');
  const hasResearchPayload = /^research-plan:/.test(plainData) || hasResearchPlanMime(e) || !!queuedResearchPlan;
  dbg('planDrop:drop:start', { plainData, hasResearchPayload, dragBuildingType, dragResearchPlan, queuedResearchPlan });
  if (!dragBuildingType && !dragResearchPlan && !queuedResearchPlan && !hasResearchPayload) return;
  e.preventDefault();
  const point = localPointInWorld(e);
  const snapped = snapPlacement(dragBuildingType || 'feature', point.x, point.y);
  dbg('planDrop:drop:snapped', { snapped });
  if (dragBuildingType === 'feature' && queuedResearchPlan) {
    const ok = commitQueuedResearchPlan(snapped);
    researchDropHandled = ok;
    if (!ok) {
      const sid = String(queuedResearchPlan.id || '');
      if (sid) alert(`Plan ${sid} not found in research queue. Re-run Research to refresh list.`);
    }
    dbg('planDrop:drop:end:queued', { ok, queuedResearchPlan });
    if (ok) state.suppressWorldClick = true;
    dragBuildingType = null;
    dragResearchPlan = null;
    queuedResearchPlan = null;
    researchDropHandled = false;
    lastResearchDragSnap = null;
    worldWrapEl.classList.remove('drop-armed');
    setPlacement(null);
    return;
  }
  let researchDrop = dragResearchPlan;
  if (!researchDrop) {
    try {
      const raw = e.dataTransfer?.getData('application/x-antfarm-research-plan') || '';
      if (raw) researchDrop = JSON.parse(raw);
      dbg('planDrop:drop:jsonPayload', { raw, parsed: researchDrop });
    } catch {}
  }
  if (!researchDrop) {
    const plain = String(e.dataTransfer?.getData('text/plain') || '');
    const m = plain.match(/^research-plan:(.+)$/);
    if (m) {
      const selectedLab = (state.selected?.type === 'building' && isResearchKind(state.selected?.data?.kind)) ? state.selected.data : null;
      const repoPath = selectedLab ? baseRepoKey(String(selectedLab.repo || '')) : '';
      const repoKey = repoPath || 'workspace-repo';
      researchDrop = { id: m[1], repoKey, repoPath };
      dbg('planDrop:drop:fallbackFromText', { researchDrop });
    }
  }
  if (researchDrop) {
    const ok = commitResearchDropFromPayload(researchDrop, snapped);
    if (!ok) {
      const sid = String(researchDrop.id || '');
      if (sid) alert(`Plan ${sid} not found in research queue. Re-run Research to refresh list.`);
    }
    if (ok) state.suppressWorldClick = true;
  } else {
    let placed = false;
    if (dragBuildingType === 'base') { placeBaseAt(snapped.x, snapped.y); placed = true; }
    if (dragBuildingType === 'feature') { placed = !!placeFeatureAt(snapped.x, snapped.y) || placed; }
    if (dragBuildingType === 'research') { placeResearchAt(snapped.x, snapped.y); placed = true; }
    if (dragBuildingType === 'warehouse') { placeWarehouseAt(snapped.x, snapped.y); placed = true; }
    if (dragBuildingType === 'university') { placeUniversityAt(snapped.x, snapped.y); placed = true; }
    if (dragBuildingType === 'library') { placeLibraryAt(snapped.x, snapped.y); placed = true; }
    if (dragBuildingType === 'power') { placePowerAt(snapped.x, snapped.y); placed = true; }
    if (placed) state.suppressWorldClick = true;
  }
  dbg('planDrop:drop:end', { dragBuildingType, dragResearchPlan });
  dragBuildingType = null;
  dragResearchPlan = null;
  queuedResearchPlan = null;
  researchDropHandled = false;
  lastResearchDragSnap = null;
  worldWrapEl.classList.remove('drop-armed');
  setPlacement(null);
});
worldWrapEl.addEventListener('dragleave', (e) => {
  if (!dragBuildingType && !dragResearchPlan) return;
  if (e.relatedTarget && worldWrapEl.contains(e.relatedTarget)) return;
  hidePlacementGhost();
});

document.addEventListener('keydown', (e) => {
  if (state.featureMode && !e.target?.closest?.('input,textarea,select') && (e.key === 'ArrowDown' || e.key === 'ArrowUp')) {
    const rows = [...document.querySelectorAll('#assignedAgentList .agent-row')];
    if (rows.length) {
      e.preventDefault();
      const currentIndex = rows.findIndex((row) => row.classList.contains('active'));
      const dir = e.key === 'ArrowDown' ? 1 : -1;
      const nextIndex = currentIndex < 0 ? (dir > 0 ? 0 : rows.length - 1) : (currentIndex + dir + rows.length) % rows.length;
      rows[nextIndex].click();
      rows[nextIndex].scrollIntoView({ block: 'nearest' });
      return;
    }
  }
  if (e.key === 'Escape') {
    closeLibraryModal();
    clearSelectedEntity();
    setPlacement(null);
    return;
  }
  if (e.target && ['INPUT','TEXTAREA','SELECT'].includes(e.target.tagName)) return;
  if (e.key === 'r' && !e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) {
    const activeRow = document.querySelector('#assignedAgentList .agent-row.active');
    const activeAgent = String(activeRow?.getAttribute?.('data-agent') || '');
    const activeIsDeveloper = /\/developer$/i.test(activeAgent);
    const developerRow = activeIsDeveloper
      ? activeRow
      : document.querySelector('#assignedAgentList .agent-row[data-agent$="/developer"]');
    const redoBtn = developerRow?.querySelector?.('.agent-redo');
    if (redoBtn) {
      e.preventDefault();
      redoBtn.click();
      return;
    }
  }
  if (e.key === 'b' || e.key === 'B') setPlacement('base');
  if (e.key === 'f' || e.key === 'F') setPlacement('feature');
  if (e.key === 'l' || e.key === 'L') setPlacement('research');
  if (e.key === 'w' || e.key === 'W') setPlacement('warehouse');
  if (e.key === 'u' || e.key === 'U') setPlacement('university');
  if (e.key === 'y' || e.key === 'Y') setPlacement('library');
  if (e.key === 'p' || e.key === 'P') setPlacement('power');
  if (e.key === 'Delete' || e.key === 'Backspace') deleteSelectedStructure();
});

const handlePointerMove = (e) => {
  if (state.cameraDrag.active) {
    state.camera.x = state.cameraDrag.originX - (e.clientX - state.cameraDrag.startX);
    state.camera.y = state.cameraDrag.originY - (e.clientY - state.cameraDrag.startY);
    updateCameraVisuals();
    const kind = dragBuildingType || state.placementMode;
    if (kind) {
      const point = localPointInWorld(e);
      showPlacementGhost(kind, point.x, point.y);
    }
    return;
  }
  if (state.draggingEntity) {
    const autoPanned = edgeAutoPan(e.clientX, e.clientY);
    const point = localPointInWorld(e);
    let kind = 'feature';
    if (state.draggingEntity.type === 'base' || state.draggingEntity.type === 'baseDraft') kind = 'base';
    else if (state.draggingEntity.type === 'university') kind = 'university';
    else if (state.draggingEntity.type === 'research') kind = 'research';
    else if (state.draggingEntity.type === 'library') kind = 'library';
    else if (state.draggingEntity.type === 'power') kind = 'power';
    else if (state.draggingEntity.type === 'warehouse') kind = 'warehouse';
    const snapped = snapPlacement(kind, point.x - state.draggingEntity.offsetX + (buildingFootprint(kind).w / 2), point.y - state.draggingEntity.offsetY + (buildingFootprint(kind).h / 2));
    state.draggingMoved = true;
    if (state.draggingEntity.type === 'base') updateCustomBasePosition(state.draggingEntity.id, snapped.x, snapped.y);
    else if (state.draggingEntity.type === 'baseDraft') updateBaseDraftPosition(state.draggingEntity.id, snapped.x, snapped.y);
    else if (state.draggingEntity.type === 'feature') updateFeaturePosition(state.draggingEntity.id, snapped.x, snapped.y);
    else if (state.draggingEntity.type === 'university') updateUniversityPosition(state.draggingEntity.id, snapped.x, snapped.y);
    else if (state.draggingEntity.type === 'research') updateResearchPosition(state.draggingEntity.id, snapped.x, snapped.y);
    else if (state.draggingEntity.type === 'library') updateLibraryPosition(state.draggingEntity.id, snapped.x, snapped.y);
    else if (state.draggingEntity.type === 'power') updatePowerPosition(state.draggingEntity.id, snapped.x, snapped.y);
    else if (state.draggingEntity.type === 'warehouse') updateWarehousePosition(state.draggingEntity.id, snapped.x, snapped.y);
    else updateRunBuildingPosition(state.draggingEntity.id, snapped.x, snapped.y);
    moveEntityVisual(state.draggingEntity.type, state.draggingEntity.id, snapped.x, snapped.y);
    if (autoPanned) queuePersist();
    return;
  }
  const kind = dragBuildingType || state.placementMode;
  if (!kind) return;
  const point = localPointInWorld(e);
  showPlacementGhost(kind, point.x, point.y);
};
window.addEventListener('mousemove', handlePointerMove);
worldWrapEl.addEventListener('mouseleave', hidePlacementGhost);

worldWrapEl.addEventListener('mousedown', (e) => {
  const target = e.target instanceof Element ? e.target : null;
  const hitEntity = !!target?.closest('.entity');
  const hitBelt = !!target?.closest('.rts-path');
  const panWithPrimary = e.button === 0 && !state.placementMode && !hitEntity && !hitBelt;
  if (e.button === 2 || e.button === 1 || (e.button === 0 && e.shiftKey) || panWithPrimary) {
    e.preventDefault();
    state.cameraDrag = {
      active:true,
      startX:e.clientX,
      startY:e.clientY,
      originX:state.camera.x,
      originY:state.camera.y
    };
  }
});
worldWrapEl.addEventListener('contextmenu', (e) => {
  if (state.cameraDrag.active || e.target === worldWrapEl || worldWrapEl.contains(e.target)) e.preventDefault();
});

window.addEventListener('mouseup', async () => {
  if (state.draggingEntity && state.draggingMoved) {
    state.suppressWorldClick = true;
    try { await persistDraggedEntityPosition(state.draggingEntity); } catch {}
    await persistNow();
    // Refresh links/labels once after drag completes, not on every mousemove.
    rebuildScene();
  }
  state.cameraDrag.active = false;
  state.draggingEntity = null;
  state.draggingMoved = false;
});

worldEl.addEventListener('click', (e) => {
  if (state.placementMode) {
    const point = localPointInWorld(e);
    const snapped = snapPlacement(state.placementMode, point.x, point.y);
    if (state.placementMode === 'base') placeBaseAt(snapped.x, snapped.y);
    if (state.placementMode === 'feature') placeFeatureAt(snapped.x, snapped.y);
    if (state.placementMode === 'research') placeResearchAt(snapped.x, snapped.y);
    if (state.placementMode === 'warehouse') placeWarehouseAt(snapped.x, snapped.y);
    if (state.placementMode === 'university') placeUniversityAt(snapped.x, snapped.y);
    if (state.placementMode === 'library') placeLibraryAt(snapped.x, snapped.y);
    if (state.placementMode === 'power') placePowerAt(snapped.x, snapped.y);
    state.suppressWorldClick = false;
    setPlacement(null);
    return;
  }
  if (state.suppressWorldClick) {
    state.suppressWorldClick = false;
    return;
  }
  if (Date.now() < Number(state.recentFeaturePlacementUntil || 0)) return;
  const target = e.target instanceof Element ? e.target : null;
  if (target?.closest('.entity, .unit, .subunit, .build-note, .rts-path')) return;
  if (state.selected) clearSelectedEntity();
});

registerServiceWorker();
initInstallPrompt();
boot();
updateCameraVisuals();
setInterval(async () => {
  const runsChanged = await refreshRuntimeState(false);
  if (!state.liveStream) startLiveStream();
  if (runsChanged) rebuildScene();
  else if (Number(state.live?.runningAgentCount || 0) > 0) {
    ensureMotionLoop();
    renderUnitsLiveState();
  } else renderUnitsLiveState();
  renderLiveConsole();
}, 2000);

window.addEventListener('beforeunload', () => {
  if (state.motionTimer) {
    clearInterval(state.motionTimer);
    state.motionTimer = null;
  }
  if (state.liveStream) {
    try { state.liveStream.close(); } catch {}
    state.liveStream = null;
  }
});
</script>
</body>
</html>
